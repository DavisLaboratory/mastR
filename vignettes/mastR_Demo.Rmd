---
title: "mastR: an R package for automatical signature screening"
author:
  - name: Jinjin Chen
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
      - Department of Medical Biology, University of Melbourne, Parkville, VIC 3010, Australia
    email: chen.j@wehi.edu.au
date: "`r format(Sys.time(), '%d %b %Y')`"
output: 
  rmarkdown::html_vignette:
    toc: true
    number-section: true
vignette: >
  %\VignetteIndexEntry{mastR_Demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 5
)
```

# Introduction

-----------------------------

**Why do we need imm sigs (cell type)**

The tumor microenvironment (TME) is made up of a diverse range of cell types (fibroblasts, epithelial cells, endothelial cells, and immune cells) as well as various extracellular components (collagens, growth factors, hormones, cytokines, etc.). TIME is reported to be highly associated with prognosis and various treatment response to many kinds of cancers.

Recent studies have highlighted the role of immune components in the TME in modulating tumor progression, making them attractive therapeutic targets. These components make up the tumor immune microenvironment (TIME), which is a subset of the TME. Subsequently, itâ€™s proved that tumour infiltrating lymphocytes (TILs) play an essential role in tumour progression, metastasis and treatment response.

This drives TILs to be a strong prognostic indicator for better precision therapy of cancer patients. And the identification of these TILs are the subject of keen research interest due to the roles of specific subset of immune cells acting on different tissues types. 

Identification of these cell types are based on flow cytometry in the past, which is limited in the granularity. But now with the advance of single cell RNA-seq and spatial transcriptomics technologies, more detailed and novel cell types or subtypes are being identified. One of the key paradygm of scRNAseq and spatial is to further investigate cell types in the TIME and understand cellullar heterogeniety in the TME. 

To quantify TILs infiltration (in bulk), estimate cellular composition (in bulk), annotate single cell types (in scRNA) or identify sample states/activities, many computational methods like cell deconvolution (CIBERSORTx), marker based annotation (CelliD) and sample scoring (singscore) are developed. But to distinguish between closely related cell types, estimate cell composition and states, a refined signature is required which typiclaly requires manual curation by domain expert. With the increasing large amount of data and cell types, this is gradually getting to be intenable and will require a different approach to automatically screen such signatures.

mastR is such a softare package designed to automatically screen signature for researchers interest, which can save a lot of time and manual labor work.

**What this package does**

*mastR*, MArkers Screening Tool in R, is a package to automatically derive signature for (immune) cell type in (cancer) tissues. 

Although there're a lot of tools developed to generate cell type specific markers, they are all designed for scRNA-seq data. And most of them utilize machine learning to select features contributing to the classification result, which is less robust and consistent across datasets when compared with statistical method, like empirical Bayesian in limma. And some of them will always return a signature even if the data doesn't have any.

Although DE analysis can also be done on scRNA data, like `Seurat::FindMarkers()`, it's reported that DE analysis done on peudo-bulk scRNA data is more robust and reliable than directly done on scRNA data.

Thus, our mastR is designed to generate a more refined list of siganture genes from multiple group comparisons based on `edgeR` and `limma` DE analysis result. The final signature is selected by rank product score test for picking up genes with high ranks in the most of comparisons. The rank can be ordered by any gene statistic generated by limma analysis. Signature can be further refined by keeping top n DEGs in specified comparison(s), which can help to improve the discrimination between similar cell types.

Another novel point of mastR is that all of the current markers generation tools only consider the genes contribution to the classification, but ignore the tissue-specificity. However, mastR can utilize the updated Cancer Cell Line Encyclopedia (CCLE) to filter out those genes with high expression in cancer cell lines. Those genes might confound immune infiltration with tumor purity when apply the signature on cancer patient sample. So it will be better to remove them and only keep the signature genes specific to immune cells only. 

mastR also allows people to build a markers pool before signature screening, which might contain all of potential markers or interesting genes. The final signature will be integrated with this pool (by intersection), which can help to constrain the final signature within the interested pathway-related genes or functional gene-sets. People can borrow the published knowledge to build this.

This report demonstrates the main functions of mastR `r packageVersion("mastR")`.

As a simple demo, here the report will specifically demonstrate the signature screening workflow of NK cells in colorectal cancer (CRC), then assess the final result by using some visualization functions.

**How does mastR screen the signature**  

- step 1. markers pool generation  
- step 2. screen markers for group specificity  
- step 3. screen markers for cancer/tissue specificity  
- step 4. combine results of step 2 & 3  
- step 5. visualize signature performance
       
**Applications**  

- a) score samples  
- b) estimate cellular proportion  
- c) single cell annotation  

# Installation

-----------------------------

`mastR` R package can be installed from Bioconductor or [GitHub](https://github.com/Gene233/mastR).

The most updated version of `mastR` is hosted on GitHub and can be installed using `devtools::install_github()` function provided by [devtools](https://cran.r-project.org/package=devtools).

```{r installation, eval=FALSE}
# if (!requireNamespace("devtools", quietly = TRUE)) {
#   install.packages("devtools")
# }
# if (!requireNamespace("mastR", quietly = TRUE)) {
#   devtools::install_github("Gene233/mastR")
# }

if (!requireNamespace("BiocManager", quietly=TRUE)) {
  install.packages("BiocManager")
}
if (!requireNamespace("mastR", quietly = TRUE)) {
  BiocManager::install("mastR")
}
```

```{r lib, message=FALSE}
library(mastR)
library(ggplot2)
library(GSEABase)
```

# Step 1. Build Immune Markers Pool

------------------------------

The first step is to define the original markers pool this analysis will be based on.

The final signature will only be the intersected genes with the markers pool. The whole gene list of the data will be regarded as the markers pool if no preliminary result or intereted genes are provided. But *note* that `markers = NULL` won't keep any special genes if they fail the filtration by edgeR.

Users can build the markers pool of interest from the available datasets or build from MSigDB, PanglaoDB or LM7/LM22 by our imported functions, if users have any preliminary knowledge about the target group type (cell type). All genes in the pool will be reserved for DE analysis even failed the filtration.

The standard pool building consists of:

- 1) generate from sources
  - a) generate from LM7/22 signature matrix for CIBERSORT
  - b) generate from MSigDB
  - c) generate from PanglaoDB
  - d) generate from customized gene list
- 2) merge gene-sets from all sources together

mastR allows specific markers to be conveniently loaded as follows:

- `NK_markers` dataset is a combination of CIBERSORT LM7, LM22 and human orthologs in mice from [Huntington](https://cancerimmunolres.aacrjournals.org/content/7/7/1162.long). It contains 114 genes in total.

- `LM7` and `LM22` are signature matrices, you can get more details by `?mastR::LM7` or `?mastR::LM22`.

- `msigdb_gobp_nk`  is a 'GeneSetCollection' object, contains genesets with gene-set name matched to 'NATURAL_KILLER' from GO:BP MSigDB v7.4 database. More details for `?mastR::msigdb_gobp_nk`.

The output of markers generation functions is either 'GeneSet' or 'GeneSetCollection' object.

## Generate from sources

To screen the immune cell subset signatures, we need to generate a markers pool first. mastR allows people to generate markers pool from multiple resources as metinoned before.

In this demo, we will load some example datasets to show how it works. The datasets used in this report have been built within the package or can be accessed publicly. You can use the following scripts to load them into your R environment.

### Markers from LM

Markers can also be generated from LM7/22 signature matrix to get immune cells markers using function `get_lm_sig()`.

- `LM7/22` are signature matrix from CIBERSORT, contains 7/22 immune cell subsets markers lists.

Users can extract markers for cell subsets matched to the given regex pattern from imported data `LM7`/`LM22`. 

By using `gsc_plot()`, an UpSetR plot across all gene-sets in the input would be printed. The input can be either 'GeneSet' or 'GeneSetCollection' objects. Using `gsc_plot()` we can see how different gene-sets intersect with each other.

```{r LM markers}
data("LM7", "LM22")
## only retrieve LM7
get_lm_sig(lm7.pattern = "^NK")

## only retrieve LM22
# get_lm_sig(lm22.pattern = "NK cells")

## collect both LM7 and LM22
LM <- get_lm_sig(lm7.pattern = "^NK", lm22.pattern = "NK cells")

LM
## show upset diagram
gsc_plot(LM)
```

### Markers from MSigDB

Gene-sets from MSigDB can also be searched and collected by function `get_gsc_sig()`.

- The Molecular Signatures Database (MSigDB) is a resource of tens of thousands of annotated gene sets for use with GSEA software, divided into Human and Mouse collections. 

Users can use the `species`, `cat`, `subcat` and `pattern` to specify which gene-sets to be added. 

All gene-sets with gene-set name matched to the regex `pattern` in the whole MSigDB would be extracted if `cat` and `subcat` are not set, otherwise only the genesets under the union of `cat` and `subcat` would be searched. 

In this demo, we'll use a small collection of MSigDB `msigdb_gobp_nk` to show how it works.

```{r MSigDB genesets, warning=FALSE}
data("msigdb_gobp_nk")
MSig <- get_gsc_sig(gsc = msigdb_gobp_nk,
                    pattern = "NATURAL_KILLER_CELL_MEDIATED")
MSig
## cut geneset name within 11 characters
gsn <- setNames(names(MSig), LETTERS[seq_along(MSig)])
for (i in seq_along(MSig)) {
  setName(MSig[[i]]) <- LETTERS[i]
}   
## show upset diagram of collected gene-sets
gsc_plot(MSig)
gsn  ## show gene-set names
```

As we can see, there're `r length(MSig)` gene-sets in MSig, which is too many for visualization. Thus, we can use another function `merge_markers()` to merge all gene-sets into one 'GeneSet' object.

The input of `merge_markers()` can be a list of vectors of genes, or a list of GeneSet objects, or a GeneSetCollection object.

```{r merge MSigDB}
## merge all genesets into one
MSig <- merge_markers(MSig)
setName(MSig) <- "MSigDB"
```

It's also available to search on the whole MSigDB without loading it yourself by setting param `data = "msigdb"` in the function, specific species or version can also be set as optional params.

### Markers from PanglaoDB

Markers from PanlaoDB can also be obtained to build the markers pool by using function `get_panglao_sig()`.

- PanglaoDB is a database for the scientific community interested in exploration of single cell RNA sequencing experiments from mouse and human. It collects and integrates data from multiple studies and present them through a unified framework.

Users can use `list_panglao_organs()` and `list_panglao_types()` functions to list all available organs and cell types on PanglaoDB website and use `get_panglao_sig()` function to retrive them.

```{r PanglaoDB markers, eval=FALSE}
## show availbable organs on PanglaoDB
list_panglao_organs()

## show available cell types of interest organ on PanglaoDB
## Number in the bracket represents the number of markers for each cell type (in both Homo and Mus).
list_panglao_types(organ = "Immune system")

## collect all "NK cells" markers from PanglaoDB website
Panglao <- get_panglao_sig(type = "NK cells")

Panglao
## number differs from 'NK cells' under list_panglao_types(organ = "Immune system"), because we only keep 'Hs' markers.
```

### Markers from customized gene list

Markers can also be generated from customized gene list. Here we use a list of natural killer (NK) cell markers from Curson et al 2019 from [Curson's Publication](https://aacrjournals.org/cancerimmunolres/article/7/7/1162/469488/A-Gene-Signature-Predicting-Natural-Killer-Cell) as a customized gene list.

- `NK_markers` dataset is a combination of CIBERSORT LM7, LM22 and human orthologs in mice from Huntington. It contains 114 genes in total.

```{r NK_markers}
## show what NK_markers looks like:
data("NK_markers")
NK_markers

## convert NK markers into 'GeneSet' object
nk_m <- GeneSet(NK_markers$HGNC_Symbol,
                geneIdType = SymbolIdentifier(),
                setName = "NK_markers")
```

## Integrate Markers Pool

Now we have multiple lists of markers from different sources, to use them in the subsequent analysis, we need to merge them together.

All markers can be merged into one 'GeneSet' object by using function `merge_markers()` we mentioned before. Each marker's origin will be saved as a data.frame under the 'longDescription' slot of the output in json format.

```{r integrate markers}
gsc <- GeneSetCollection(c(nk_m, LM, MSig)) ## add Panglao if you run it
Markers <- merge_markers(gsc)

## upset plot
gsc_plot(gsc)

Markers

## to show the table summary of merged list
head(jsonlite::fromJSON(GSEABase::longDescription(Markers)))
```

Now we get a large markers pool for screening, next we need to screen signature genes from the pool for both cell subset and tissue specificity.

# Step 2. Specify Markers Against Other Cell Subsets

------------------------------------

For cell subset specificity, there're 4 main steps:

- a) process data: filtration, normalization, sample weighting and linear model fit
- b) differential expression (DE) analysis  
- c) feature selection: pick differentially expressed genes with high ranks in most of comparisons
- d) integrate selected genes with markers pool

Customized external data is accepted in diverse formats: DGEList, eSet, matrix... For example, a large collection of 1561 bulk RNA-seq samples generated by DICE from pure populations of human immune cells, can be used to as input data. It can be loaded by function `celldex::DatabaseImmuneCellExpressionData()`, which contains 5 main cell types and 15 fine cell types.

In this demo, we use our imported example data `im_data_6` from [GSE60424](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE60424) as input. Only samples from healthy individuals are kept, and 'Whole Blood' or 'PBMC' cells are removed in dataset. It can also be obtained by `GEOquery::getGEO()`.

- `im_data_6` is a eSet object, containing RNA-seq TMM normalized counts data of 6 sorted immune cell subsets * 4 samples. More details in `?mastR::im_data_6`.

```{r im_data_6}
data("im_data_6")
im_data_6
```

## process data

To screen signature for cell subset specificity, some processes need to be done on the data first.

`process_data()` provided by mastR can do the genes filtration, data normalization, samples weighting, linear model fit and the computation of gene differential expression statistic for you.

It will return a `DGEList` object with filtered counts (unfiltered counts data will be saved under "original"), vfit (`limma::voom()` is done), tfit (`limma::lmFit()` and `limma::treat()` are done).

What this function does is:

- Data will be filtered by the given cutoff, all gene with low expression will be removed by edgeR.

- If the given data is raw count data (`normalize = TRUE`), further normalization 'TMM' and `limma::voom()` fit will be done inside the process function, otherwise the `trend` of limma will be applied on the given data.

- Final linear model will be fitted.

- gene statistic for DE analysis are computed by `limma::treat()`. 

Let's see what cell types are in `im_data_6`.

```{r type names}
table(im_data_6$`celltype:ch1`)
```

With below simple params, data processing can be easily done by `process_data()`:

* `data` param can be a bulk RNA-seq expression object with cell subset labels, can be matrix, eSet, DGEList, ... (expression must be either raw counts or logcounts).
* `group_col` param can specify the column name of groups (labels), can be a vector when `data` is a matrix.  
* `target_group` param can specify the cell target_group name of interest. Users can choose one name in `group_col` vector.  
* `markers` param could specify a geneset to be kept no matter if they pass the filtration. Setting it to `NULL` can skip this. Must be gene SYMBOL ID.  
* `gene_id` specify the gene ID type of rownames of data when markers is not NULL, could be one of 'ENSEMBL', 'SYMBOL', 'ENTREZ'..., default 'SYMBOL'.

More optional param details can be found in `help(proc_data)`

```{r process data}
proc_data <- process_data(
  data = im_data_6,  
  group_col = "celltype:ch1",
  target_group = "NK", 
  markers = geneIds(Markers),
  gene_id = "ENSEMBL" ## rownames of im_data_6 is ENSEMBL ID
  # summary = TRUE ## if to show the summary of tfit result
)
# summary(limma::decideTests(proc_data$tfit))
```

## visualize QC before and after

After data processing, we need to check whether the data has been well filtered , normalized and fitted.

mastR provides visualization functions for this, to compare the data before and after `process_data()` and see how well the QC is done.

To see if the low quality genes are removed, `plot_diagnostics()` can be used to show the expression distribution, RLE and MDS plots.

```{r plot diagnostics, fig.width=10, fig.height=5}
expr1 <- edgeR::cpm(im_data_6@assayData$exprs, log = TRUE) ## or proc_data$original_counts
expr2 <- proc_data$vfit$E
## plot expression distribution, RLE and MDS
plot_diagnostics(
  expr1,
  expr2,
  group_col = proc_data$samples$celltype.ch1
)
```

Mean-variance trend can be plot by `plot_mean_var()` to show the linear fit result.

```{r plot mean-variance, fig.width=10, fig.height=5}
## plot mean-variance trend
plot_mean_var(proc_data)
```

PCA can be plot by `pca_matrix_plot()` to show the normalization result and if the samples can be clustered by groups. You can select how many top n PCs to be plot by param `n`.

```{r plot PCA mat, fig.width=8, fig.height=6}
## plot PCA
## before process
pca_matrix_plot(expr1, group_by = proc_data$samples$celltype.ch1, n = 3)
## after process
pca_matrix_plot(expr2, group_by = proc_data$samples$celltype.ch1, n = 3)
```

## select signature genes

Now we get processed data with DE statistic for each gene in each comparison, then the proc_data can be passed into `select_sig()` function for further genes selection based on rank product scoring. Cell type specific signature can be obtained by this.

* `feature_selection` param to choose whether to use rank product ('rankproduct') or not ('none') to select DEGs from multiple comparisons of DE analysis. Default "auto" will perform "rankproduct" and switch to "none" if the number of final "UP" and "DOWN" genes are < 5.

```{r select sig}
## get the same result as there's permutation test for rank product
set.seed(123)
sig_ct <- select_sig(tfit = proc_data)

head(sig_ct)
```

***Note***: All above steps from 4.1.1 to 4.1.3 for screening cell subset signature can be done by one integrated function `get_degs()`.

`get_degs()` function can filter low expression genes out from immune dataset, normalize and fit voom model to data if `normalize = TRUE`, then a processed data `proc_data` object and a differentially expressed GeneSetCollection ('UP' and 'DOWN') will be returned as output.

Plot can also be done at the same time by setting optional param `plot = TRUE`.

```{r DEG_6, eval=FALSE, fig.width=8, fig.height=5}
DEG_6 <- get_degs(
  data = im_data_6,  
  group_col = "celltype:ch1",
  target_group = "NK", 
  plot = TRUE, ## show QC plots after filtration
  markers = geneIds(Markers),
  gene_id = "ENSEMBL"  ## convert ensembl IDs of rownames into symbols if gene_id != "SYMBOL"
)
## `proc_data` object would be saved
proc_data <- DEG_6$proc_data

DEG_6$DEGs
GSEABase::geneIds(DEG_6$DEGs)
DEG_6$proc_data$vfit$design ## show the design matrix
```

## intersect with markers pool {#intersect-pool}

After getting specific signature genes for the target group, we will only keep those UP regulated genes which are also present in our markers pool `Markers`, to constrain the final signature wthin the interested gene list.

PCA can be used to show clearer separation of NK cells from other cells by using our screened UP DEGs. And the intersected genes with markers pool explain more variance in PC1 compared with non-intersected DEGs.

```{r markers for cell type, fig.width=8, fig.height=6}
## convert ensembl IDs into symbols to match markers pool
deg_up <- mapIds(org.Hs.eg.db::org.Hs.eg.db,
                 geneIds(sig_ct[["UP"]]),
                 "SYMBOL", "ENSEMBL")
## markers specific for NK cells
m_ct <- intersect(geneIds(Markers), deg_up)
names(m_ct) <- names(deg_up)[match(m_ct, deg_up)]  ## set ensembl ID as names for downstream visualization

m_ct

## PCA shows clear separation of NK cells
## after intersection
pca_matrix_plot(proc_data$vfit$E[names(m_ct),],
                group_by = proc_data$samples$celltype.ch1,
                n = 3) + ggtitle("After intersection")
## before intersection
pca_matrix_plot(proc_data$vfit$E[names(deg_up),],
                group_by = proc_data$samples$celltype.ch1,
                n = 3) + ggtitle("Before intersection")
```

***Note***: There's also a wrapper function `filter_subset_sig()` which can directly do the whole Step 2 in one step. The result would be the same as running the above workflow step by step.

`filter_subset_sig()` can also be helpful when you have multiple datasets (more details in Section \@ref(multi-data)). It can output final signature after aggregating signature lists from all datasets.

```{r filter_subset_sig, eval=FALSE}
# run by wrapped function in one-step
set.seed(123)
m_ct <- filter_subset_sig(
  data = im_data_6,
  markers = geneIds(Markers),
  group_col = "celltype:ch1",
  target_group = "NK",
  gene_id = "ENSEMBL"
)
```

# Step 3. Specify Markers Against Tissue

After screening signature for cell subset specificity, we need to increase the tissue specificity for the signature now, what we need to do is:

- filter out cancer cell expressed genes  
      Collect all interested cancer cell lines from CCLE (default), compute the quantile (25% percentile default) expression of all non-0 expressed genes. Only keep genes with median expression < quantile cutoff in cancer cells. Then keep the intersected genes with markers pool.  
      By doing this, we can guarantee the activity of our final signature for infiltrating immune cells won't be affected by tumor purity when it's applied on tumor samples.  
- optional  
      DE analysis to compare tumor infiltrating immune cells vs normal immune cells (e.g. PBMC or normal tissue resident immune cells), add DEGs into markers pool or combine it with the result of step 2. to increase tissue/cancer specificity.  

mastR provides function `filter_non_tissue()` to remove cancer cells expressing genes from the markers pool. This can ensure our immune signature won't be affected by tumor purity.

Based on the `data` input format, this function can be used in 2 ways:  

* use CCLE as input  
* use customized data as input

## use CCLE as input

The default setting of this `filter_non_tissue()` uses CCLE from [DepMap CCLE](https://depmap.org/portal/download/), containing RSEM quantified TPM data of 1392 cancer cell lines (until 2022.04).  

The Cancer Cell Line Encyclopedia (CCLE) is a compilation of gene expression, chromosomal copy number and massively parallel sequencing data from more than 1,000 human cancer cell lines.

To specify cell subset markers for cancer type, use `filter_non_tissue()` function to remove failing genes which are also highly expressed by CRC adherent cell lines *per se*. This can ensure our immune signature won't be affected by tumor purity.

* `data` can be either "CCLE" or expression dataset, e.g. matrix, eSet, DGEList, Seurat and so on.  
* `group_col` param is the group vector of input samples, or the name of group column.  
* `target_group` param is an expression pattern to specify the tissue of interest, here we choose 'colorectal' to select all colorectal adherent cell lines.  
* `ignore.case` means whether to ignore the capital or not.  
* `log = FALSE` will not do log transformation to the data.  
* `q` param is the threshold to remove failing genes. 0.25 means removing markers with median expression >= 25% percentile of non-zero expression of all genes.  
* `markers` param is the markers pool.

```{r CCLE, eval=FALSE}
## load CCLE data
CCLE <- depmap::depmap_TPM()
CCLE_meta <- depmap::depmap_metadata()
## filter
m_ccl <- filter_non_tissue(data = "CCLE",
                           group_col = "primary_disease",
                           target_group = "colorectal",
                           markers = geneIds(Markers),
                           ccle_tpm = CCLE, ## only provided when data = 'CCLE'
                           ccle_meta = CCLE_meta)
## or without loading CCLE yourself
m_ccl <- filter_non_tissue(group_col = "primary_disease",
                           target_group = "colorectal",
                           markers = geneIds(Markers))
```

## use customized dataset as input

In this demo, we use a small imported dataset `ccle_crc_5` in mastR as a customized dataset.

* `ccle_crc_5` is a DGEList object only contains 5 CRC cell line samples from CCLE. More details for `help(ccle_crc_5)`.

```{r markers for cancer cell line}
data("ccle_crc_5")
ccle_crc_5[1:10,]

## markers against for CRC cell lines
m_ccl <- filter_non_tissue(data = ccle_crc_5,
                           group_col = "cancer",
                           target_group = "CRC",
                           markers = geneIds(Markers))

head(m_ccl)
```

# Step 4. Final Cell Subset Signature for Cancer

After Step 1-3, now we need to integrate the results together. As we want the final signature to be specific to the target cell subset while less affected by the tissue/cancer purity, intersection is preferred to select the final signature after both specificity screening: cell type (subset) and cancer (tissue) type.

```{r final signatures}
sig_NK_CRC <- intersect(m_ct, m_ccl)
sig_NK_CRC
```

Now we get the final signature specific for both cell type and cancer type!

# Step 5. Visualize The Curation Effect {.tabset .tabset-fade .tabset-pills}

----------------------------------

Now that we get our specific signature, we need to assess how well this siganture can perform. To easily realize this, some popular visualization functions are implemented in mastR.

- `pca_matrix_plot()` for matrix of PCA plots with top n PCs.
- `sig_heatmap()` for signature heatmap across groups and its comparsion with markers pool.
- `sig_rankdensity_plot()` for signature genes rank density distribution across groups.
- `sig_boxplot()` for signature expression or singscore boxplot across groups.
- `sig_scatter_plot()` for signature expression scatter plot of the target group vs all other groups respectively.
- `sig_gseaplot()` for gene-set enrichment analysis result display, `clusterProfiler::GSEA()` analysis is done inside this function, can choose to display 'dotplot' or gseaplot' by `clusterProfiler::GSEA()`.

## PCA matrix plot

To see if our curated NK cells signature has more distinguishable expression pattern from other immune cell subsets, we can use PCA plot again here to show it.

Loadings can be drawn to show which genes are relevant to NK cells, and result shows most of signature genes are indicating NK cells.

```{r pca, fig.width=8, fig.height=6}
## as proc_data shows better discrimination, use it for visualization
proc_data$voomE <- proc_data$vfit$E
pca_matrix_plot(
  data = proc_data, 
  features = sig_NK_CRC, 
  group_by = "celltype.ch1",
  gene_id = "ENSEMBL",
  slot = "voomE",
  n = 3
)

## loadings can be shown by setting loading = TRUE
pca_matrix_plot(
  data = proc_data, 
  features = sig_NK_CRC, 
  loading = TRUE,
  group_by = "celltype.ch1",
  gene_id = "ENSEMBL",
  slot = "voomE",
  n = 3
)
```


## Heatmap

`sig_heatmap()` function can plot the original NK cells markers and curated signatures expression pattern heatmaps in immune datasets.

* `sigs` param is the final curated signature symbols, while `markers` param is the original markers pool.  
* `scale` could specify the `column` or `row` to be scaled or no scaling by `none`.  
* `rank_plot`` is used to decide if to gene rank instead of expression for heatmap.
* `normalize` means whether to normalize and calculate logCPM or not.    

```{r heatmap, warning=FALSE, fig.width=10, fig.height=7}
sig_heatmap(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  markers = geneIds(Markers),
  gene_id = "ENSEMBL",
  slot = "voomE",
  scale = "row",
  show_column_den = FALSE,
  show_row_den = FALSE,
  show_column_names = FALSE,
  show_row_names = FALSE
)

## for multiple datasets
# sig_heatmap(
#   data = list(data_6 = im_data_6,
#               proc_data = proc_data), 
#   sigs = sig_NK_CRC,
#   group_col = c("celltype:ch1", "celltype.ch1"), 
#   markers = geneIds(Markers),
#   normalize = TRUE,
#   gene_id = "ENSEMBL"
# ) + patchwork::plot_layout(guides = "collect", ncol = 1)
```

We can see the expression pattern of the signature is more distinguishable in NK cells.

## Rank Density Plot

Use `sig_rankdensity_plot()` function to make rank density plot for all cell subsets in the data.

By setting `aggregate = TRUE`, only one plot for each cell type with mean expression would be shown.

We might want to see the rank density plot in more than 1 datasets for comparison, this can be done by simply passing a list of datasets to function.

```{r rankdensity plot, fig.width=8, fig.height=5, warning=FALSE, results='hide'}
# ## visualization on both original and processed data
# sig_rankdensity_plot(
#   data = list(im_data_6 = im_data_6,
#               process_Data = proc_data), 
#   sigs = sig_NK_CRC,
#   normalize = c(TRUE, FALSE),
#   group_col = c("celltype:ch1", "celltype.ch1"), 
#   gene_id = "ENSEMBL",
#   slot = "voomE"
# )

## visualization on aggregated data
sig_rankdensity_plot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  aggregate =  TRUE,
  gene_id = "ENSEMBL",
  slot = "voomE"
)
```

We can find, processed data shows more digstinguishable rankdensity distribution of screened NK signature genes.

## Signature Score Boxplot

To see if the curated NK cells signatures have evident higher abundance in NK cells than other immune cell subsets, use `sig_boxplot()` function to make boxplot of the NK scores for all cell subsets in the data.

NK score is calculated by `singscore` package.

```{r score boxplot, warning=FALSE}
sig_boxplot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  target_group = "NK", 
  normalize = FALSE,
  gene_id = "ENSEMBL",
  slot = "voomE"
)

## To make boxplots for more than 1 immune datasets at once:
# sig_boxplot(
#   data = list(data_6 = im_data_6,
#               proc_data = proc_data), 
#   sigs = sig_NK_CRC,
#   group_col = c("celltype:ch1", "celltype.ch1"),
#   target_group = "NK",
#   normalize = TRUE,
#   gene_id = "ENSEMBL"
# ) * guides(col = "none")
```

Obviously, our signature always shows significantly higher score in NK cells.

## Signature Abundance Boxplot

`sig_boxplot()` function can also generate boxplot of the NK signature abundance for all cell subsets in the data by setting `type = "expression"`.

```{r abundance boxplot, warning=FALSE}
sig_boxplot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  target_group = "NK",
  type = "expression",
  gene_id = "ENSEMBL",
  slot = "voomE"
)
```

It's clear the score can increase the difference between NK cells and others.

## Signature Abundance Scatter Plot

To see if the curated NK cells signature shows higher specificity to NK cells than other immune cell subsets. Use `sig_scatter_plot()` function to make scatter plot of the NK signature abundance for all cell subsets in the data.

```{r abundance scatter plot, warning=FALSE, fig.width=8, fig.height=5}
sig_scatter_plot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  target_group = "NK",
  xint = 4, yint = 4,
  gene_id = "ENSEMBL",
  slot = "voomE"
)

## To make scatter plot for more than 1 immune datasets at once:
# sig_scatter_plot(
#   data = list(data_6 = im_data_6,
#               proc_data = proc_data), 
#   sigs = sig_NK_CRC,
#   group_col = c("celltype:ch1", "celltype.ch1"),
#   target_group = "NK", 
#   xint = 4, yint = 4,
#   normalize = TRUE, 
#   gene_id = "ENSEMBL")
```

Based on scatter plot result, we can actually do further filtration to improve signature specificity by removing signature genes present in right bottom or left bottom region.

## Signature GSEA plot

To see if the curated signature is enriched in NK cells than other immune cell subsets. Use `sig_gseaplot()` function to make GSEAplot.

```{r gseaplot, warning=FALSE, fig.width=10, fig.height=7}
## gseaplot
sig_gseaplot(
  data = proc_data,
  sigs = list(sig = sig_NK_CRC, markers = geneIds(Markers)),
  group_col = "celltype.ch1",
  target_group = "NK",
  gene_id = "ENSEMBL",
  slot = "voomE"
)
## dotplot
sig_gseaplot(
  data = proc_data, 
  sigs = list(sig = sig_NK_CRC, markers = geneIds(Markers)),
  group_col = "celltype.ch1", 
  target_group = "NK",
  gene_id = "ENSEMBL",
  slot = "voomE",
  method = "gseaplot"
)
```

It's clear that our screened signature is enriched in all comparisons.

# Refine Signature Specificity

----------------------------------

According to the visualization result, we can see our NK signature shows good performance in separating NK cells with all other cells. But CD8+ T cells still show similar abundance to NK cells in some signature genes expression, which might impair the ability of signature to distinguish NK cells from CD8+ T cells.

But we know those genes with similar abundance across NK and CD8+ T are importance and distinguishable for separating NK cells from other non-CD8+ T cells. So we don't recommend to simply delete those genes based on our abundance scatter plot. 

Instead, here we implemented a better way to increase the difference between the ambiguous cell types.

By setting `keep.top` and `keep.group`, we can easily keep the top n DEGs of specified DE comparisons, DEGs are ranked based on `Rank` param. For instance, here we want keep more distinguishable genes between NK and CD8+ T cells, we can set `keep.group = "CD8"` or `keep.group = "NK-CD8"`. `keep.top` can specify how many top genes in that comparison should be kept.

```{r signature refine}
## keep top 200 DEGs in 'NK-CD8'
set.seed(123)
m_ct_refine <- filter_subset_sig(
  data = im_data_6, 
  markers = geneIds(Markers),
  group_col = "celltype:ch1",
  target_group = "NK",
  gene_id = "ENSEMBL",
  keep.top = 200,
  keep.group = "CD8"
)

## get 8 more new signature genes
sig_NK_CRC_refine <- intersect(m_ct_refine, m_ccl)
setdiff(sig_NK_CRC_refine, sig_NK_CRC)

## most NK-CD8 top DEGs are not in the markers pool
deg_tables <- get_de_table(
  data = im_data_6, 
  group_col = "celltype:ch1",
  target_group = "NK"
)
intersect(mapIds(org.Hs.eg.db::org.Hs.eg.db,
                 rownames(deg_tables$`NK-CD8`)[1:200],
                 "SYMBOL", "ENSEMBL"),
          geneIds(Markers))  ## only 19 out of top 200 DEGs are in the pool
```

We only get `r sum(sig_NK_CRC_refine %in% sig_NK_CRC)` more new genes when keeping top 200 DEGs in 'NK-CD8', that's because majority of those genes are not in our markers pool `Markers` and can't pass the screening step. So it would be better to create a large enough pool for screening in case we miss any useful DEGs.

## Visualization after refinement

After the refinement, we have 2 signature lists now. By comparing the 2 signatures performance, we can see the difference of NK vs CD4 and CD8 T cells increased, but the difference vs monocytes and neutrophils dropped a bit.

```{r score boxplot refine, warning=FALSE, fig.width=8, fig.height=5}
p1 <- sig_boxplot(
  data = proc_data, 
  sigs = sig_NK_CRC_refine,
  group_col = "celltype.ch1", 
  target_group = "NK", 
  gene_id = "ENSEMBL",
  slot = "voomE"
) + ggtitle("Signature after Refinement")
p2 <- sig_boxplot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  target_group = "NK", 
  gene_id = "ENSEMBL",
  slot = "voomE"
) + ggtitle("Signature before Refinement")

(p1 + p2)*ylim(-0.5,0.4) + patchwork::plot_layout(guides = "collect")
```

Abundance scatter plot also shows more specific genes to NK compared with CD4/8 T cells.

```{r abundance scatter plot refine, warning=FALSE, fig.width=8, fig.height=6}
## after refine
sig_scatter_plot(
  data = proc_data, 
  sigs = sig_NK_CRC_refine,
  group_col = "celltype.ch1", 
  target_group = "NK",
  xint = 4, yint = 4,
  gene_id = "ENSEMBL",
  slot = "voomE"
) + ggtitle("Signature after Refinement")
## before refine
sig_scatter_plot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  target_group = "NK",
  xint = 4, yint = 4,
  gene_id = "ENSEMBL",
  slot = "voomE"
) + ggtitle("Signature before Refinement")
```


# Screen on Multiple Datasets

----------------------------------

Till now, the whole workflow of mastR usage is complete.

But this demo is just a show case on single dataset, mastR can also be applied on multiple datasets. 

After the Step 2d (Section \@ref(intersect-pool)), for:  

- 1) single dataset  
      Return the intersection result as the signature.  
- 2) multiple datasets  
      After Step 2d, choose one combination method (`union` default) to aggregate signature lists generated from different datasets. Robust Rank Aggregation ("RRA") is another method to select in mastR, which detects genes that are ranked consistently better than expected under null hypothesis of uncorrelated inputs and assigns a significance score for each gene. 

Instead of integrating datasets into one larger dataset to fit into one linear model, we screen signature in each dataset respectively and users can choose to aggregate the ranked lists via `RobustRankAggreg` method by setting `comb = "RRA"` (as our output of signature by screening function is ordered based on the given `Rank`).

The advantage is that we can avoid over-normalizing or mis-correcting when carrying out data integration. And we can get more robust and conserved signature across datasets. It's better than "RemoveBatchEffect" sometimes.

Of course, easy way such as "union" and "intersect" is also supported besides "RRA" (Robust Rank Aggreg), by setting `comb = union` or `comb = intersect`.

It's better to use union when you get only a few genes screened for each dataset, while "RRA" is better to pick up significant genes from large DEG lists, "intersect" is proper for highly overlapping gene lists.

Here, we will repeatedly use im_data_6 to show how it works on multiple datasets.

```{r screen multiple datasets, eval=FALSE}
## In the demo, we just repeatedly use im_data_6 as a show case
set.seed(123)
m_ct_m <- filter_subset_sig(
  data = list(A = im_data_6, B = im_data_6), 
  markers = geneIds(Markers),
  group_col = "celltype:ch1",
  target_group = "NK",
  gene_id = "ENSEMBL"
)

## we will get exactly the same list
## if we choose 'union' or 'intersect' as combination
setequal(m_ct_m, m_ct)

## but we will only get the genes appear at top rank across gene lists
## if we choose 'RRA', s_thres is to determine the threshold for ranking score
set.seed(123)
m_ct_m <- filter_subset_sig(
  data = list(A = im_data_6, B = im_data_6), 
  markers = geneIds(Markers),
  group_col = "celltype:ch1",
  target_group = "NK",
  gene_id = "ENSEMBL",
  comb = "RRA",  ## change this to use different strategy, default is "union"
  s_thres = 0.5  ## only work when comb = "RRA", set a threshold for ranking score
)

## we can get only 8 signature genes this time
m_ct_m
```


# Screen on scRNA data {#multi-data}

----------------------------------

Although mastR is developed for bulk RNA data, to make use of abundant scRNA resource, mastR also provides `pseudo_samples()` function to help convert scRNA data into pseudo-bulk data, which can then be used in the above workflow.

`pseudo_samples()` can help aggregate cells into pseudo-sample according to the given factor(s).

```{r pseudo-bulk, eval=FALSE}
## create a test scRNA object of 100 genes x 100 cells
counts <- matrix(abs(rpois(10000, 10)), 100)
rownames(counts) <- 1:100
colnames(counts) <- 1:100
meta <- data.frame(
  subset = rep(c("A", "B"), 50),
  level = rep(1:4, each = 25)
)
rownames(meta) <- 1:100
pb <- pseudo_samples(counts, by = meta)

pb <- edgeR::DGEList(counts = pb, group = gsub("\\..*", "", colnames(pb)))

filter_subset_sig(pb, group_col = "group", target_group = "A")

## Seurat or SCE object are also accepted
# scRNA <- Seurat::CreateSeuratObject(counts = counts, meta.data = meta)
# pseudo_samples(scRNA, by = c("subset","level"))
```


# Application on Simulated data {.tabset .tabset-fade .tabset-pills}

After getting the signature, we can apply it in multple ways. In this short demo, we will just show 3 simple applications of it.

Here we will simulate a scRNA data using `splatter`. Then randomly pseudo-bulking it to generate pseudo bulk data for scoring and deconvolution.

```{r simulation, eval=FALSE}
library(splatter)
## set seed for reproduce as there's permutation inside
set.seed(123)

sim_params <- newSplatParams(
  nGenes = 1000,
  batchCells = 3000,
  group.prob = seq(0.1, 0.4, length.out = 4),
  de.prob = 0.02,
  # de.downProb = 0,  ## only set up-regulated genes for each group
  de.facLoc = 0.5,
  de.facScale = 0.4
)

data_sim <- splatSimulate(sim_params, method = "groups")

markers_list <- lapply(rowData(data_sim)[,paste0("DEFacGroup", 1:4)],
                       \(x) rownames(data_sim[x > 1]))

## aggregate into pseudo-bulk samples
pb <- pseudo_samples(data_sim,
                     by = c("Batch", "Group"),
                     min.cells = 50, max.cells = 100)
dge <- DGEList(
  counts = pb,
  samples = data.frame(group = gsub(".*\\.(.*)_.*", "\\1",colnames(pb)),
                       Batch = gsub("(.*)\\..*", "\\1",colnames(pb)),
                       sampleID = gsub("(.*)_.*", "\\1",colnames(pb)))
)
```

```{r get sigs, eval=FALSE, fig.height=4}
set.seed(123)
sig_ls <- lapply(paste0("Group", 1:4), \(x) {
  filter_subset_sig(
    data = dge,
    markers = NULL,
    group_col = "group",
    target_group = x,
    lfc = 0
  )
})
names(sig_ls) <- paste0("Group", 1:4)

## venn plot
p <- lapply(1:4, \(i) ggvenn::ggvenn(list(sig = sig_ls[[i]],
                                          marker = markers_list[[i]]),
                                     show_percentage = FALSE) +
              ggtitle(names(sig_ls)[i]))
patchwork::wrap_plots(p)

## heatmap
sig_heatmap(
  cpm(dge, log = TRUE),
  sigs = c(sig_ls, list("TP53")), ## add a real gene to pass gene check
  group_col = dge$samples$group,
  scale = "row",
  show_column_den = FALSE,
  show_row_den = FALSE,
  cluster_column_slices = FALSE,
  cluster_row_slices = FALSE
)
```

```{r random pseudo-bulk, eval=FALSE}
library(dplyr)
## randomly generate aggregating idx
set.seed(123)
data_sim$rand_idx <- sample.int(30, ncol(data_sim), replace = TRUE)

## aggregate into pseudo-bulk samples based on rand_idx
pb_r <- pseudo_samples(data_sim, by = c("Batch", "rand_idx"))
dge_r <- DGEList(
  counts = pb_r,
  samples = data.frame(group = gsub(".*\\.(.*)_.*", "\\1",colnames(pb_r)),
                       Batch = gsub("(.*)\\..*", "\\1",colnames(pb_r)),
                       sampleID = gsub("(.*)_.*", "\\1",colnames(pb_r)))
)

## append cellular composition
tmp <- as.data.frame(data_sim@colData) |>
  group_by(rand_idx, Group) |>
  summarise(count = n()) |>
  pivot_wider(names_from = Group, values_from = count) |>
  mutate(rand_idx = factor(rand_idx))
tmp[,-1] <- signif(tmp[,-1] / rowSums(tmp[,-1]), 2)
dge_r$samples <- left_join(dge_r$samples, tmp, by = c("group" = "rand_idx"))

## data process
keep <- filterByExpr(dge_r)
dge_r <- dge_r[keep,, keep.lib.sizes = FALSE]
dge_r <- calcNormFactors(dge_r, method = "TMM")
```

## Score

```{r score, eval=FALSE}
library(singscore)

rank_data <- rankGenes(edgeR::cpm(dge_r, log = TRUE))

## score based on sig_ls
scores <- multiScore(rank_data, upSetColc = gls2gsc(sig_ls))

tmp <- pivot_longer(cbind(Sample = colnames(dge_r), dge_r$samples[,6:9]),
                    -Sample, names_to = "Group", values_to = "Prop")

tmp <- t(scores$Scores) |> 
  data.frame(Sample = colnames(scores$Scores)) |> 
  pivot_longer(-Sample, names_to = "Group", values_to = "Score") |> 
  left_join(tmp)

ggplot(tmp, aes(x = Prop, y = Score, col = Group)) +
  geom_point() +
  facet_wrap(~Group, scales = "free") +
  ggpubr::stat_cor() +
  theme_classic()

## score based on markers_list
scores <- multiScore(rank_data, upSetColc = gls2gsc(markers_list))

tmp <- pivot_longer(cbind(Sample = colnames(dge_r), dge_r$samples[,6:9]),
                    -Sample, names_to = "Group", values_to = "Prop")
tmp$Group <- paste0("DEFac", tmp$Group)

tmp <- t(scores$Scores) |> 
  data.frame(Sample = colnames(scores$Scores)) |> 
  pivot_longer(-Sample, names_to = "Group", values_to = "Score") |> 
  left_join(tmp)

ggplot(tmp, aes(x = Prop, y = Score, col = Group)) +
  geom_point() +
  facet_wrap(~Group, scales = "free") +
  ggpubr::stat_cor() +
  theme_classic()
```

## Deconvolution

```{r deconv, eval=FALSE}
sig_matrix <- DWLS::buildSignatureMatrixMAST(
  scdata = data_sim@assays@data$counts[unique(unlist(sig_ls)),],
  id = data_sim$Group,
  path = tempdir()
)

res <- DWLS::solveDampenedWLS(sig_matrix, pb_r[rownames(sig_matrix),])
```


## Annotation

```{r annotation, eval=FALSE}
library(singscore)
## normalization
data_sim <- scuttle::computePooledFactors(data_sim, clusters = data_sim$Group)
data_sim <- scuttle::logNormCounts(data_sim)
## use singscore for annotation
rank_data <- rankGenes(data_sim@assays@data$logcounts)

## score using sig_ls
scores <- multiScore(rank_data, upSetColc = gls2gsc(sig_ls))
data_sim$Pred <- paste0("Group", apply(scores$Scores, 2, which.max))
table(data_sim$Pred == data_sim$Group)

## score using markers_list
scores <- multiScore(rank_data, upSetColc = gls2gsc(markers_list))
data_sim$Pred <- paste0("Group", apply(scores$Scores, 2, which.max))
table(data_sim$Pred == data_sim$Group)
```


# Session Info

---------------------

```{r session info}
sessionInfo()
```

# References

---------------------

>Cursons J, Souza-Fonseca-Guimaraes F, Foroutan M, Anderson A, Hollande F, Hediyeh-Zadeh S, Behren A, Huntington ND, Davis MJ. A Gene Signature Predicting Natural Killer Cell Infiltration and Improved Survival in Melanoma Patients. Cancer Immunol Res. 2019 Jul;7(7):1162-1174. doi: 10.1158/2326-6066.CIR-18-0500. Epub 2019 May 14. PMID: 31088844.

