---
title: "mastR_Demo"
author:
  - name: Jinjin Chen
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
      - Department of Medical Biology, University of Melbourne, Parkville, VIC 3010, Australia
    email: chen.j@wehi.edu.au
date: "`r format(Sys.time(), '%d %b %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{mastR_Demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

-----------------------------

- *Why do we need imm sigs (cell type)*

Tumour immune microenvironment (TIME) is reported to be highly associated with prognosis and various treatment response to many kinds of cancers. Itâ€™s also proved that tumour infiltrating lymphocytes (TILs) play an essential role in tumour progression, metastasis and treatment response. Thus, to identify the extent or population of the specific immune subset in specific tissue type, would be an interesting topic for many immunologists.

But to annotate cell types, estimate cellular composition or identify sample states (activities), refined signature is needed for the specified cells, which always requires large amount of manual work of experts. To save time and reduce manual labor work, mastR is developed to automatically screen signature for users interest.  

- *What this package does*

This report demonstrates how to use the functions in R package `mastR 0.1.0` to screen immune subset signatures in specific tissue and visualize the effects of the curation.

`mastR` is developed to screen immune cells signature in cancer tissues. So there are several datasets imported into this package for running by default. But users could specify other immune subsets and other tissues by setting the parameters in the R functions. Next, this report will show how the workflow runs to refine NK cells signatures which are specific for CRC, and how to visualize the results effect.  
 
- How does mastR screen the signature  
 - step 1. markers pool generation  
     Markers pool can be built from MSigDB, PanglaoDB or LM7/LM22 by our imported functions, if users have any preliminary knowledge about the target group type (cell type). All genes in the pool will be reserved for DE analysis even failed the filtration.  
     The final signature will only be the intersected genes with the markers pool. The whole gene list of the data will be regarded as the markers pool if no preliminary result or intereted genes are provided. But *note* that `markers = NULL` won't keep any special genes if they fail the filtration by edgeR.  
     
 - step 2. screen markers for group specificity  
   - a) process data  
       Data will be filtered by given cutoff, all gene with low expression will be removed by edgeR. If the given data is raw count data, further normalization 'TMM' and fit by `limma::voom()` will be done.  
       Then final linear model will be fitted and passed to `limma::treat()` to compute gene statistics for DE analysis.  
   - b) DE analysis  
   - c) feature selection based on rank product  
   - d) intersect with markers pool
     
 - step 3. screen markers for cancer/tissue specificity  
   - filter out cancer cell expressed genes  
       Collect all interested cancer cell lines from CCLE (default), compute the quantile (25% percentile default) expression of all non-0 expressed genes. Only keep genes with median expression < quantile cutoff in cancer cells. Then keep the intersected genes with markers pool.  
       By doing this, we can guarantee the activity of our final signature for infiltrating immune cells won't be affected by tumor purity when it's applied on tumor samples.  
   - optional
       DE analysis to compare tumor infiltrating immune cells vs normal immune cells (e.g. PBMC or normal tissue resident immune cells), add DEGs into markers pool or combine it with the result of step 2. to increase tissue/cancer specificity.  
       
 - step 4. combine results of step 2 & 3
   - a) single dataset  
       Keep the intersection of step 2 and 3 results.  
   - b) multiple datasets
       After 4. a), choose one assemble method to aggregate signature lists generated by different datasets. Robust Rank Aggregation ("RRA") is the default method to do this in mastR, which detects genes that are ranked consistently better than expected under null hypothesis of uncorrelated inputs and assigns a significance score for each gene. It's better than "RemoveBatchEffect" sometimes.  
       
 - step 5. visualize signature performance
   - Use multiple visualization ways to assess the performance of screened signature.  
       
- Applications
  - a) score samples
  - b) estimate cellular proportion
  - c) single cell annotation

# Installation

-----------------------------

Install `mastR` R package from [GitHub](https://github.com/Gene233/mastR).
The most updated version of `mastR` is hosted on GitHub and can be easily installed using `devtools::install_github()` function provided by [devtools](https://cran.r-project.org/package=devtools).

```{r installation, eval=FALSE}
# if (!requireNamespace("devtools", quietly = TRUE)) {
#   install.packages("devtools")
# }
# if (!requireNamespace("mastR", quietly = TRUE)) {
#   devtools::install_github("Gene233/mastR")
# }

if (!requireNamespace("BiocManager", quietly=TRUE)) {
  install.packages("BiocManager")
}
if (!requireNamespace("mastR", quietly = TRUE)) {
  BiocManager::install("mastR")
}
```

# Step 1. Prepare Immune Markers Pool

------------------------------

## Load Datasets

Here's step 1. To screen the immune subset signatures, we have to load the example datasets. The datasets used in this report have been built within the package or can be accessed publicly. You can use the following scripts to load them into your R environment.

`NK_markers` dataset is a combination of CIBERSORT LM7, LM22 and human orthologs in mice from [Huntington](https://cancerimmunolres.aacrjournals.org/content/7/7/1162.long). It contains 114 genes in total.

`LM7` and `LM22` are signature matrices, you can get more details by `?mastR::LM7` or `?mastR::LM22`.

`im_data_6` is a eSet object, containing RNA-seq TMM normalized counts data of 6 sorted immune subsets. More details in `?mastR::im_data_6`.

```{r setup}
library(mastR)
library(ggplot2)
library(GSEABase)
```

### NK markers from [Curson's Publication](https://aacrjournals.org/cancerimmunolres/article/7/7/1162/469488/A-Gene-Signature-Predicting-Natural-Killer-Cell)

```{r NK_markers}
## show what NK_markers looks like:
data("NK_markers")
NK_markers
```

### Markers from LM

Users can extract markers for subsets matched to the given regex pattern from imported data `LM7`/`LM22`. 

The matched genes will be saved in 'GeneSet' class object, if both pattern are provided, the output would be a 'GeneSetCollection' class object with setName: LM7, LM22.

```{r LM markers}
data("LM7", "LM22")
## only retrieve LM7
get_lm_sig(lm7.pattern = "^NK")

## only retrieve LM22
get_lm_sig(lm22.pattern = "NK cells")

## collect both LM7 and LM22
LM <- get_lm_sig(lm7.pattern = "^NK", lm22.pattern = "NK cells")

LM
## show upset diagram
gsc_plot(LM)
```

### Markers from MSigDB

The users can specify the `species`, `cat`, `subcat` and `pattern` to decide which genesets to be added. 

All genesets with geneset name matched to the `pattern` in the whole MSigDB would be extracted if `cat` and `subcat` are not set, otherwise only the genesets under the union of `cat` and `subcat` would be searched. 

By setting `plot = TRUE`, an UpSetR plot across matched genesets would be printed.

```{r MSigDB genesets, fig.width=12}
## collect all "natural killer mediated" relavent genesets from MSigDB
# MSig <- get_gsc_sig(gsc = "msigdb",
#                     pattern = "NATURAL_KILLER_CELL_MEDIATED",
#                     cat = "c5", subcat = "GO:BP",
#                     version = '7.4',
#                     species = "hs")
data("msigdb_gobp_nk")
MSig <- get_gsc_sig(gsc = msigdb_gobp_nk,
                    pattern = "NATURAL_KILLER_CELL_MEDIATED")
MSig
## show upset diagram of collected gene-sets
gsc_plot(MSig)

## merge all genesets into one
MSig <- merge_markers(MSig)
setName(MSig) <- "MSigDB"
```

### Markers from PanglaoDB

Users can use `list_panglao_organs()` and `list_panglao_types()` functions to list all available organs and cell types on PanglaoDB website and use `get_panglao_sig()` function to retrive them.

```{r PanglaoDB_NK}
## show availbable organs on PanglaoDB
list_panglao_organs()

## show available cell types of interest organ on PanglaoDB
## Number in the bracket represents the number of markers for each cell type (in both Homo and Mus).
list_panglao_types(organ = "Immune system")

## collect all "NK cells" markers from PanglaoDB website
Panglao <- get_panglao_sig(type = "NK cells")

Panglao
## number differs from 'NK cells' under list_panglao_types(organ = "Immune system"), because we only keep 'Hs' markers.
```

## Integrate Markers Pool

Finally, all markers can be merged into one 'GeneSet' object by using function `merge_markers()`.

The input can be a list of vectors of genes, or a list of GeneSet objects, or a GeneSetCollection object. `plot = TRUE` requires the list to have > 1 elements.

```{r integrate markers}
nk_m <- NK_markers$HGNC_Symbol |> 
    GeneSet(geneIdType = SymbolIdentifier(), setName = "NK_markers")

gsc <- GeneSetCollection(c(nk_m, LM, MSig, Panglao))
Markers <- merge_markers(gsc)

## upset plot
gsc_plot(gsc)

Markers

## to show the table summary of merged list
head(jsonlite::fromJSON(GSEABase::longDescription(Markers)))
```

# Screen Immune Subset Signatures

------------------------------------

## Step 2. Specify Markers Against Other Immune Subsets {.tabset .tabset-fade .tabset-pills}

You can use `celldex::DatabaseImmuneCellExpressionData()` to load a large collection of 1561 bulk RNA-seq samples generated by DICE from pure populations of human immune cells. It contains 5 main cell types and 15 fine cell types. Here to save time, we use our example data `im_data_6` as input.

The example uses `im_data_6` from [GSE60424](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE60424).

* `im_data_6` consists 6 immune subsets * 4 samples, the data type is 'TMM normalized counts data'.

Only samples from healthy individuals are kept, and 'Whole Blood' or 'PBMC' cells are removed in dataset.

```{r im_data_6}
data("im_data_6")
im_data_6

idx <- c(
  "lib.size", "donorid.ch1", "smoker.ch1",
  "cellcount.ch1", "collectiondate.ch1",
  "celltype.ch1", "gender.ch1"
)
edgeR::DGEList(
  counts = exprs(im_data_6),
  samples = pData(im_data_6)
)[["samples"]][, idx]
```

### process data

To find the passing genes, low expression genes filtration needs to be done first. `process_data()` can help to do this, when `normalize = TRUE`, further normalization and voom fit will be done after filtration. The data will be returned with filtered counts (unfiltered counts data will be saved under "original"), vfit after `limma::voom()` and tfit after `limma::lmFit()` and `limma::treat()`.

`get_degs()` function can filter low expression genes out from immune dataset, normalize and fit voom model to data if `normalize = TRUE`, then a processed data `proc_data` object and a differentially expressed GeneSetCollection ('UP' and 'DOWN') will be returned as output.

* `data` param can be a bulk RNA-seq expression object with subset labels, can be matrix, eSet, DGEList, ...  
* `group_col` param can specify the column name of groups (labels), can be a vector when `data` is a matrix.  
* `target_group` param can specify the cell target_group name of interest. Users can choose one name in `group_col` vector.  
* `normalize` param indicates if the input data is raw counts data. If `normalize = FALSE`, the function would directly use the expression data *per se* to filter out genes instead of calculating CPM.  
* `feature_selection` param to choose whether to use rank product ('rankproduct') or 'none' to select DEGs from multiple comparisons of DE analysis, default 'auto' uses 'rankproduct' but change to 'none' if final genes < 5 for both UP and DOWN.  
* `plot = TRUE` would visualize the QC results before and after filtration. It would make log hist plot, RLE plot, MDS plot and SA plot.  
* `markers` param could specify a geneset to be kept no matter if they pass the filtration. Setting it to `NULL` can skip this.  
* `gene_id` specify the gene ID type of rownames of data when markers is not NULL, could be one of 'ENSEMBL', 'SYMBOL', 'ENTREZ'..., default 'SYMBOL'.  

Let's see what cell types are in `im_data_6`.

```{r type names}
im_data_6$`celltype:ch1` |> unique()
```

```{r process data}
proc_data <- process_data(
  data = im_data_6,  
  group_col = "celltype:ch1",
  target_group = "NK", 
  markers = geneIds(Markers),
  gene_id = "ENSEMBL", ## rownames of im_data_6 is ENSEMBL ID
  summary = TRUE ## if to show the summary of tfit result
)
# summary(limma::decideTests(proc_data$tfit))
```

mastR also provides visualizations for data process, to compare the data before and after `process_data()` and see how well the QC is done.

```{r plot diagnostics, fig.width=8, fig.height=5}
expr1 <- edgeR::cpm(proc_data$original_counts, log = TRUE)
expr2 <- proc_data$vfit$E
## plot expression distribution, RLE and MDS
plot_diagnostics(
  expr1,
  expr2,
  group_col = proc_data$samples$celltype.ch1
)
## plot mean-variance trend
plot_mean_var(proc_data)
## plot PCA
pca_matrix_plot(expr1, group_by = proc_data$samples$celltype.ch1) +
pca_matrix_plot(expr2, group_by = proc_data$samples$celltype.ch1)
```

### select DEGs

Then proc_data can be passed into `select_sig()` function for further genes selection based on rank product scoring. Cell type specific signature can be obtained by this.

* `feature_selection` param to choose whether to use rank product ('rankproduct') or 'none' to select DEGs from multiple comparisons of DE analysis. Default "auto" will perform "rankproduct" and switch to "none" if the number of final "UP" and "DOWN" genes are < 5.

```{r select sig}
## get the same result as there's permutation test for rank product
set.seed(123)
sig_ct <- select_sig(tfit = proc_data$tfit)
```

All above steps for screening subset signature can be done by one integrated function `get_degs()`.

```{r DEG_6, eval=FALSE, fig.width=8, fig.height=5}
DEG_6 <- get_degs(
  data = im_data_6,  
  group_col = "celltype:ch1",
  target_group = "NK", 
  plot = TRUE, ## show QC plots after filtration
  markers = geneIds(Markers),
  gene_id = "ENSEMBL"  ## convert ensembl IDs of rownames into symbols if gene_id != "SYMBOL"
)
## `proc_data` object would be saved
proc_data <- DEG_6$proc_data

DEG_6$DEGs
GSEABase::geneIds(DEG_6$DEGs)
DEG_6$proc_data$vfit$design ## show the design matrix
```

### intersect with markers pool

Then we will only keep those UP regulated genes which are also in our markers pool `Markers`.

We can see PCA shows clearer separation between NK cells and other cells by using screened UP DEGs. And intersected genes explain more variance in PC1 compared with non-intersected DEGs.

```{r markers for cell type, fig.width=8, fig.height=4}
## convert ensembl IDs into symbols to match markers pool
deg_up <- mapIds(org.Hs.eg.db::org.Hs.eg.db,
                 geneIds(sig_ct[["UP"]]),
                 "SYMBOL", "ENSEMBL")
## markers specific for NK cells
m_ct <- intersect(geneIds(Markers), deg_up)
names(m_ct) <- names(deg_up)[match(m_ct, deg_up)]  ## set ensembl ID as names for downstream visualization

m_ct

## PCA shows clear separation of NK cells
pca_matrix_plot(proc_data$vfit$E[names(m_ct),],
                group_by = proc_data$samples$celltype.ch1) +
  pca_matrix_plot(proc_data$vfit$E[names(deg_up),],
                  group_by = proc_data$samples$celltype.ch1)
```

There's a wrapper function `filter_subset_sig()` which can directly do the whole in one step. The result would be the same as running the workflow step by step

`filter_subset_sig()` can also be helpful when you have multiple datasets. It can output final signature after aggregating signature lists from all datasets by using "RRA".

```{r filter_subset_sig, eval=FALSE}
# run by wrapped function in one-step
set.seed(123)
m_ct <- filter_subset_sig(
  data = im_data_6,
  markers = geneIds(Markers),
  group_col = "celltype:ch1",
  target_group = "NK",
  gene_id = "ENSEMBL"
)
```


## Step 3. Specify Markers Against Tissue

The example uses `CCLE_tpm` from [DepMap CCLE](https://depmap.org/portal/download/), containing RSEM quantified TPM data of 1392 cancer cell lines (until 2022.04).  

To specify NK markers for CRC, use `filter_non_tissue()` function to remove failing genes which are also highly expressed by CRC adherent cell lines *per se*.

* `data` can be either "CCLE" or expression dataset, e.g. matrix, eSet, DGEList, Seurat and so on.  
* `group_col` param is the group vector of input samples, or the name of group column.  
* `target_group` param is an expression pattern to specify the tissue of interest, here we choose 'colorectal' to select all colorectal adherent cell lines.  
* `ignore.case` means whether to ignore the capital or not.  
* `log = TURE` would do log transformation to the data.  
* `q` param is the threshold to remove failing genes. 0.25 means removing markers with median expression >= 25% percentile of non-zero expression of all genes.  
* `markers` param is the updated markers pool.

```{r CCLE, eval=FALSE}
CCLE <- depmap::depmap_TPM()
CCLE_meta <- depmap::depmap_metadata()
m_ccl <- filter_non_tissue(data = "CCLE",
                           group_col = "primary_disease",
                           target_group = "colorectal",
                           markers = geneIds(Markers),
                           ccle_tpm = CCLE,
                           ccle_meta = CCLE_meta)
## or without loading CCLE yourself
m_ccl <- filter_non_tissue(group_col = "primary_disease",
                           target_group = "colorectal",
                           markers = geneIds(Markers))
```

For fast test, here we only selected 5 CRC cell line samples as a small test dataset `ccle_crc_5`.

```{r markers for cancer cell line}
data("ccle_crc_5")
ccle_crc_5[1:10,]

## markers against for CRC cell lines
m_ccl <- filter_non_tissue(data = ccle_crc_5,
                           group_col = "cancer",
                           target_group = "CRC",
                           markers = geneIds(Markers))
## as CCLE is default setting, this can also be easily run without loading CCLE
# m_ccl <- filter_non_tissue(target_group = "colorectal",
#                            markers = geneIds(Markers))

head(m_ccl)
```

## Step 4. Final NK Cells Signature for CRC

Select the Signature which pass both criteria: cell type and cancer cell line.

```{r final signatures}
sig_NK_CRC <- intersect(m_ct, m_ccl)
sig_NK_CRC
```

# Step 5. Visulize The Curation Effect {.tabset .tabset-fade .tabset-pills}

----------------------------------

## PCA matrix plot

To see if curated NK cells signatures have more distinguishable expression pattern from other immune subsets, we can use PCA plot again here to show it.

Loading can be drawn to show which genes are relevant to NK cells, and result shows most of signature genes are indicating NK cells.

```{r pca, fig.width=8, fig.height=5}
## as proc_data shows better discrimination, use it for visualization
proc_data$voomE <- proc_data$vfit$E
pca_matrix_plot(
  data = proc_data, 
  features = sig_NK_CRC, 
  group_by = "celltype.ch1",
  gene_id = "ENSEMBL",
  slot = "voomE"
)

## loadings can be shown by setting loading = TRUE
pca_matrix_plot(
  data = proc_data, 
  features = sig_NK_CRC, 
  loading = TRUE,
  group_by = "celltype.ch1",
  gene_id = "ENSEMBL",
  slot = "voomE"
)
```


## Heatmap

`result_heatmap()` function can plot the original NK cells markers and curated signatures expression pattern heatmaps in immune datasets.

* `sigs` param is the final curated signature symbols, while `markers` param is the original markers pool.  
* `scale` could specify the `column` or `row` to be scaled or no scaling by `none`.  
* `min_max` is used to decide if to apply min-max normalization to each row of expression data.
* `normalize` means whether to normalize and calculate logCPM or not.    
* Users are able to specify the color of heatmap by setting `color` param.


We can see the expression pattern of cutrated signature is more distinguishable in NK cells.

```{r heatmap, warning=FALSE, fig.width=10, fig.height=7}
sig_heatmap(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  markers = geneIds(Markers),
  gene_id = "ENSEMBL",
  slot = "voomE"
)

## for multiple datasets
# sig_heatmap(
#   data = list(data_6 = im_data_6,
#               proc_data = proc_data), 
#   sigs = sig_NK_CRC,
#   group_col = c("celltype:ch1", "celltype.ch1"), 
#   markers = geneIds(Markers),
#   normalize = TRUE,
#   gene_id = "ENSEMBL",
#   # col = colorRampPalette(c(rgb(1, 1, 0), "red"))(256)  ## can customize heatmap color
# ) + patchwork::plot_layout(guides = "collect", ncol = 1)
```


## Rank Density Plot

Use `sig_rankdensity_plot()` function to make rank density plot for all subsets in the data.

By setting `aggregate = TRUE`, only one plot for each cell type with mean expression would be shown.

We might want to see the rank density plot in more than 1 datasets for comparison, this can be done by simply passing a list of datasets to function.

We can find, processed data shows more digstinguishable rankdensity distribution of screened NK signature genes.

```{r rankdensity plot, fig.width=8, fig.height=5, warning=FALSE, results='hide'}
# ## visualization on both original and processed data
# sig_rankdensity_plot(
#   data = list(im_data_6 = im_data_6,
#               process_Data = proc_data), 
#   sigs = sig_NK_CRC,
#   normalize = c(TRUE, FALSE),
#   group_col = c("celltype:ch1", "celltype.ch1"), 
#   gene_id = "ENSEMBL",
#   slot = "voomE"
# )

## visualization on aggregated data
sig_rankdensity_plot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  aggregate =  TRUE,
  gene_id = "ENSEMBL",
  slot = "voomE"
)
```


## NK Score Boxplot

To see if the curated NK cells signatures have evident higher abundance in NK cells than other immune subsets, use `sig_boxplot()` function to make boxplot of the NK scores for all subsets in the data.

NK score is calculated by `singscore` package.

Obviously, our signature always shows significantly higher score in NK cells.

```{r score boxplot, warning=FALSE}
sig_boxplot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  target_group = "NK", 
  normalize = FALSE,
  gene_id = "ENSEMBL",
  slot = "voomE"
)

## To make boxplots for more than 1 immune datasets at once:
# result_score_boxplot(data = list(data_6 = im_data_6,
#                                  proc_data = proc_data), 
#                      sigs = sig_NK_CRC,
#                      group_col = c("celltype:ch1", "celltype.ch1"),
#                      target_group = "NK",
#                      normalize = TRUE,
#                      gene_id = "ENSEMBL") *
#   guides(col = "none")
```


## NK Signature Abundance Boxplot

`result_exp_boxplot()` function can also generate boxplot of the NK signature abundance for all subsets in the data by setting `plot.score = FALSE`.

It's clear the score can increase the difference between NK cells and others.

```{r abundance boxplot, warning=FALSE}
sig_boxplot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  target_group = "NK",
  plot.score = FALSE,
  gene_id = "ENSEMBL",
  slot = "voomE"
)
```


## NK Signature Abundance Scatter Plot

To see if the curated NK cells signature shows higher specificity to NK cells than other immune subsets. Use `sig_scatter_plot()` function to make scatter plot of the NK signature abundance for all subsets in the data.

Based on sactter plot result, we can actually do further filtration to improve signature specificity.

```{r abundance scatter plot, warning=FALSE, fig.width=8, fig.height=5}
sig_scatter_plot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  target_group = "NK",
  xint = 4, yint = 4,
  gene_id = "ENSEMBL",
  slot = "voomE"
)

## To make scatter plot for more than 1 immune datasets at once:
# sig_scatter_plot(
#   data = list(data_6 = im_data_6,
#               proc_data = proc_data), 
#   sigs = sig_NK_CRC,
#   group_col = c("celltype:ch1", "celltype.ch1"),
#   target_group = "NK", 
#   xint = 4, yint = 4,
#   normalize = TRUE, 
#   gene_id = "ENSEMBL")
```


## NK Signature GSEA plot

To see if the curated NK cells signature is enriched in NK cells than other immune subsets. Use `sig_gseaplot()` function to make GSEAplot.

It's clear that our screened signature is enriched in all comparisons.

```{r gseaplot, fig.width=8, fig.height=5, warning=FALSE}
# ## gseaplot
# sig_gseaplot(
#   data = proc_data, 
#   sigs = sig_NK_CRC,
#   group_col = "celltype.ch1", 
#   target_group = "NK",
#   gene_id = "ENSEMBL",
#   slot = "voomE"
# )
## dotplot
sig_gseaplot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  target_group = "NK",
  gene_id = "ENSEMBL",
  slot = "voomE",
  method = "dotplot"
)
```


# Refine Signature Specificity

----------------------------------

According to the visualization result, we can see our NK signature shows good performance in separating NK cells with all other cells. But CD8+ T cells still show similar abundance to NK cells in some signature genes expression, which might impair the ability of signature to distinguish NK cells from CD8+ T cells.

But we know those genes with similar abundance across NK and CD8+ T are importance and distinguishable for separating NK cells from other non-CD8+ T cells. So we don't recommend to simply delete those genes based on our abundance scatter plot. 

Instead, here we implemented a better way to increase the difference between the ambiguous cell types.

By setting `keep.top` and `keep.group`, we can easily keep the top n DEGs of specified DE comparisons, DEGs are ranked based on `Rank` param. For instance, here we want keep more distinguishable genes between NK and CD8+ T cells, we can set `keep.group = "CD8"` or `keep.group = "NK-CD8"`. `keep.top` can specify how many top genes in that comparison should be kept.

We only get 2 more new genes when keeping top 200 DEGs in 'NK-CD8', that's because majority of those genes are not in our markers pool `Markers` and can't pass the screening. So it would be better to create a large enough pool for screening in case we miss any useful DEGs.

```{r signature refine}
## keep top 200 DEGs in 'NK-CD8'
set.seed(123)
m_ct_refine <- filter_subset_sig(
  data = im_data_6, 
  markers = geneIds(Markers),
  group_col = "celltype:ch1",
  target_group = "NK",
  gene_id = "ENSEMBL",
  keep.top = 200,
  keep.group = "CD8"
)

## get 8 more new signature genes
sig_NK_CRC_refine <- intersect(m_ct_refine, m_ccl)
setdiff(sig_NK_CRC_refine, sig_NK_CRC)

## most NK-CD8 top DEGs are not in the markers pool
deg_tables <- get_de_table(
  data = im_data_6, 
  group_col = "celltype:ch1",
  target_group = "NK"
)
intersect(mapIds(org.Hs.eg.db::org.Hs.eg.db,
                 rownames(deg_tables$`NK-CD8`)[1:200],
                 "SYMBOL", "ENSEMBL"),
          geneIds(Markers))  ## only 19 out of top 200 DEGs are in the pool
```


## Visualization after refinement

We can see the difference of NK vs CD4 and CD8 T cells increased, but the difference vs monocytes and neutrophils dropped a bit.

```{r score boxplot refine, warning=FALSE, fig.width=8, fig.height=5}
p1 <- sig_boxplot(
  data = proc_data, 
  sigs = sig_NK_CRC_refine,
  group_col = "celltype.ch1", 
  target_group = "NK", 
  gene_id = "ENSEMBL",
  slot = "voomE"
) + ggtitle("Signature after Refinement")
p2 <- sig_boxplot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  target_group = "NK", 
  gene_id = "ENSEMBL",
  slot = "voomE"
) + ggtitle("Signature before Refinement")

(p1 + p2)*ylim(-0.5,0.4) + patchwork::plot_layout(guides = "collect")
```

Abundance scatter plot also shows more specific genes to NK compared with CD4/8 T cells.

```{r abundance scatter plot refine, warning=FALSE, fig.width=8, fig.height=3}
p1 <- sig_scatter_plot(
  data = proc_data, 
  sigs = sig_NK_CRC_refine,
  group_col = "celltype.ch1", 
  target_group = "NK",
  xint = 4, yint = 4,
  gene_id = "ENSEMBL",
  slot = "voomE"
) + ggtitle("Signature after Refinement")
p2 <- sig_scatter_plot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  target_group = "NK",
  xint = 4, yint = 4,
  gene_id = "ENSEMBL",
  slot = "voomE"
) + ggtitle("Signature before Refinement")

(p1 + p2) + patchwork::plot_layout(guides = "collect")
```


# Screen on Multiple Datasets

----------------------------------

Our package can be applied on multiple datasets. Instead of integrating datasets into one larger dataset to fit into one linear model, we screen signature in each dataset respectively and aggregating ranked lists via `RobustRankAggreg` method (as our output of signature by screening function is ordered based on the given `Rank`).

The advantage is that we can avoid over-normalizing or mis-correcting when carrying out data integration. And we can get more robust and conserved signature across datasets.

Of course, easy way such as "union" and "intersect" is also supported besides "RRA" (Robust Rank Aggreg), by setting `comb = union` or `comb = intersect`.

It's better to use union when you get only a few genes screened for each dataset, while "RRA" is better to pick up significant genes from large DEG lists, "intersect" is proper for highly overlapping gene lists.

```{r screen multiple datasets, eval=FALSE}
## As a test, we just repeatly use im_data_6 as a show case
set.seed(123)
m_ct_m <- filter_subset_sig(
  data = list(A = im_data_6, B = im_data_6), 
  markers = geneIds(Markers),
  group_col = "celltype:ch1",
  target_group = "NK",
  gene_id = "ENSEMBL"
)

## we will get exactly the same list
## if we choose 'union' or 'intersect' as combination
setequal(m_ct_m, m_ct)

## but we will only get the genes appear at top rank across gene lists
## if we choose 'RRA', s_thres is to determine the threshold for ranking score
set.seed(123)
m_ct_m <- filter_subset_sig(
  data = list(A = im_data_6, B = im_data_6), 
  markers = geneIds(Markers),
  group_col = "celltype:ch1",
  target_group = "NK",
  gene_id = "ENSEMBL",
  comb = "RRA",  ## change this to use different strategy, default is "union"
  s_thres = 0.5  ## only work when comb = "RRA", set a threshold for ranking score
)

## we can get only 8 signature genes this time
m_ct_m
```


# Screen on scRNA data

----------------------------------

We also provide pseudo-sample functions in this package to help users convert scRNA data into pseudo-bulk data, which can then be used in our above workflow.

`pseudo_samples()` can help aggregate cells into pseudo-sample according to the given factor.

```{r pseudo-bulk, eval=FALSE}
## create a test scRNA object of 100 genes x 100 cells
counts <- matrix(abs(rpois(10000, 10)), 100)
rownames(counts) <- 1:100
colnames(counts) <- 1:100
meta <- data.frame(
  subset = rep(c("A", "B"), 50),
  level = rep(1:4, each = 25)
)
rownames(meta) <- 1:100
pb <- pseudo_samples(counts, by = meta)

pb <- edgeR::DGEList(counts = pb, group = gsub("\\..*", "", colnames(pb)))

filter_subset_sig(pb, group_col = "group", target_group = "A")

## Seurat or SCE object are also accepted
# scRNA <- Seurat::CreateSeuratObject(counts = counts, meta.data = meta)
# pseudo_samples(scRNA, by = c("subset","level"))
```



# Session Info

---------------------

```{r session info}
sessionInfo()
```

# References

---------------------

>Cursons J, Souza-Fonseca-Guimaraes F, Foroutan M, Anderson A, Hollande F, Hediyeh-Zadeh S, Behren A, Huntington ND, Davis MJ. A Gene Signature Predicting Natural Killer Cell Infiltration and Improved Survival in Melanoma Patients. Cancer Immunol Res. 2019 Jul;7(7):1162-1174. doi: 10.1158/2326-6066.CIR-18-0500. Epub 2019 May 14. PMID: 31088844.

