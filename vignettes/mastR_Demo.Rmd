---
title: "mastR: an R package for automatical signature screening"
author:
  - name: Jinjin Chen
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
      - Department of Medical Biology, University of Melbourne, Parkville, VIC 3010, Australia
    email: chen.j@wehi.edu.au
  - name: Ahmed Mohamed
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
    email: mohamed.a@wehi.edu.au
  - name: Chin Wee Tan
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
    email: cwtan@wehi.edu.au
date: "`r format(Sys.time(), '%d %b %Y')`"
output: 
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{mastR_Demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 5
)
```

# Introduction

------------------------------------------------------------------------

**Why do we need group markers**

In biological and clinical research, the identification of biomarkers specific to a disease, tissue, or cell type is a critical step in advancing our understanding and application of this knowledge.

Specific biomarkers can be identified through various methods, such as transcriptomics, proteomics, or metabolomics, which can provide a global view of the molecular landscape of the system being studied.

To denote these biomarkers, we use the term "group markers" in a generic sense, referring to any molecular feature that is specific to a particular group or condition of interest.

Such markers can provide insight into disease diagnosis, prognosis, and treatment options, and can help to differentiate between diseased and healthy states. Thus the identification of the group markers is crucial in various biological and medical applications, as it allows us to distinguish between different cell types or disease states.

For example, in cancer research, identifying marker genes that are differentially expressed between cancer cells and normal cells can help diagnose and monitor the progression of the disease, as well as identify potential therapeutic targets. Similarly, in developmental biology, identifying marker genes that are specific to certain cell types or stages can help us understand the underlying mechanisms of differentiation and development.

Furthermore, marker genes can also be used in diagnostic assays to detect specific diseases or monitor treatment responses. For instance, the presence of certain marker genes in a patient's blood or tissue sample can indicate the presence or progression of a disease.

Overall, identifying marker genes for specific groups is crucial for understanding biological processes, diagnosing diseases, and developing targeted therapies.

**Why do we need immune signature (cell type)**

In this demo, we will be using the example of immune cell signature in the context of the tumour microenvironment as a practical case study to showcase the application of our approach.

The tumor microenvironment (TME) is made up of a diverse range of cell types (fibroblasts, epithelial cells, endothelial cells, and immune cells) as well as various extracellular components (collagens, growth factors, hormones, cytokines, etc.). TIME is reported to be highly associated with prognosis and various treatment response to many kinds of cancers.

Recent studies have highlighted the role of immune components in the TME in modulating tumor progression, making them attractive therapeutic targets. These components make up the tumor immune microenvironment (TIME), which is a subset of the TME. Subsequently, it's proved that tumour infiltrating lymphocytes (TILs) play an essential role in tumour progression, metastasis and treatment response.

This drives TILs to be a strong prognostic indicator for better precision therapy of cancer patients. And the identification of these TILs are the subject of keen research interest due to the roles of specific subset of immune cells acting on different tissues types.

Identification of these cell types are based on flow cytometry in the past, which is limited in the granularity. But now with the advance of single cell RNA-seq and spatial transcriptomics technologies, more detailed and novel cell types or subtypes are being identified. One of the key paradygm of scRNAseq and spatial is to further investigate cell types in the TIME and understand cellullar heterogeniety in the TME.

To quantify TILs infiltration (in bulk), estimate cellular composition (in bulk), annotate single cell types (in scRNA) or identify sample states/activities, many computational methods like cell deconvolution (CIBERSORTx), marker based annotation (CelliD) and sample scoring (singscore) are developed. But to distinguish between closely related cell types, estimate cell composition and states, a refined signature is required which typiclaly requires manual curation by domain expert. With the increasing large amount of data and cell types, this is gradually getting to be intenable and will require a different approach to automatically screen such signatures.

mastR is a software package specifically designed to automatically screen signatures of interest for particular research questions. This automated process saves significant time and effort that would otherwise be required for manual labor.

**What this package does**

*mastR*, MArkers Screening Tool in R, is a package to automatically derive signature for specific group of interest in specific tissue.

With mastR, users can simply input their expression data containing the groups of interest, along with group labels, to obtain a list of marker genes (signature) for the target group.

While there are many tools available for generating cell type-specific markers, they are primarily designed for scRNA-seq data and often rely on machine learning algorithms to select relevant features for classification. However, these methods may lack robustness and consistency across datasets when compared to using statistical methods like empirical Bayesian in `limma`. Furthermore, some of these tools may return a signature even when the data does not contain any, leading to potential inaccuracies.

Although differential expression (DE) analysis can also be done on scRNA data, like `Seurat::FindMarkers()`, it's reported that DE analysis done on peudo-bulk scRNA data is more robust and reliable than directly done on scRNA data.

Thus, mastR is designed to generate a more refined list of signature genes from multiple group comparisons based on the results from `edgeR` and `limma` DE analysis workflow. The final signature is selected by rank product score test for picking up genes with high ranks in the most of comparisons. The rank can be ordered by any gene statistic generated by limma analysis. Signature can be further refined by keeping the top n DEGs in the specified comparison(s), which can help to improve the discrimination between fairly similar cell types.

Another unique advantage of mastR is that it takes into account the background noise of tissue-specificity, which is often ignored by other marker generation tools. Unlike most tools that only consider the genes' contribution to the classification, mastR also offers a background noise removal function. This function is designed to remove parts of the marker genes that are highly expressed in specific tissues or cancer cells. These signals from the background, regarded as background noise, can cause potential ambiguity when applying the markers to specific tissues due to background or sample purity issues. This feature makes mastR apart and enhances the accuracy and specificity of the generated markers.

Furthermore, mastR allows users to build a markers pool before signature screening, which might contain the potential markers of interest to the users. The final signature will be integrated with this pool (by intersection), which can help to constrain the final signature within the interested pathway-related genes or functional gene-sets. People can borrow the published knowledge to build this.

The motivation of this package arises from the importance and necessity of identifying specific genes that are differentially expressed in different groups or tissues, as these genes can serve as biomarkers for diagnosis, prognosis, and therapeutic targeting. However, identifying marker genes can be a challenging and time-consuming task, and the presence of background noise can lead to erroneous results. Our package simplifies and streamlines this process, allowing researchers to focus on their analyses and interpretations without the burden of manual marker gene selection and background noise removal.

This report demonstrates the main functions and applications of mastR `r packageVersion("mastR")`.

This report demonstrates the signature screening workflow of NK cells in colorectal cancer (CRC), assessing the results by using in-built visualization functions.

**mastR screen the signature using the following 3 key steps:**

  step 1. generate markers pool  
  step 2. screen markers from the pool  
  step 3. visualize signature performance

**Applications**

- score samples
- estimate cellular proportion
- single cell annotation

# Installation

------------------------------------------------------------------------

`mastR` R package can be installed from Bioconductor or [GitHub](https://github.com/Gene233/mastR).

The most updated version of `mastR` is hosted on GitHub and can be installed using `devtools::install_github()` function provided by [devtools](https://cran.r-project.org/package=devtools).

```{r installation, eval=FALSE}
# if (!requireNamespace("devtools", quietly = TRUE)) {
#   install.packages("devtools")
# }
# if (!requireNamespace("mastR", quietly = TRUE)) {
#   devtools::install_github("Gene233/mastR")
# }

if (!requireNamespace("BiocManager", quietly=TRUE)) {
  install.packages("BiocManager")
}
if (!requireNamespace("mastR", quietly = TRUE)) {
  BiocManager::install("mastR")
}
```

```{r lib, message=FALSE}
library(mastR)
library(ggplot2)
library(GSEABase)
```

# Step 1. Build Markers Pool

------------------------------------------------------------------------

The first step is to define the original markers pool this analysis will be based on.

The final signature will only be the intersected genes with this markers pool. The whole gene list of the data will be regarded as the markers pool if no preliminary result or interested genes are provided.

***Note*** that `markers = NULL` won't keep any special genes if they fail the filtration by edgeR.

If users have any preliminary knowledge about the target group type (cell type), they can build the markers pool of interest from the available datasets or build from MSigDB, PanglaoDB or LM7/LM22 using our in-built functions. All genes in the pool will be reserved for DE analysis even even if they are filtered out during the filtration of edgeR.

The standard pool building process involves the following:

1)  generate from sources  
    i)  LM7/22 signature matrix for CIBERSORT  
    ii)  MSigDB  
    iii)  PanglaoDB  
    iv)  Customized gene list  
2)  merge gene-sets together

mastR allows some markers to be conveniently loaded as follows:

- `LM7` and `LM22` are immune cells signature matrices for CIBERSORT, you can get more details by `?mastR::LM7` or `?mastR::LM22`.

- `msigdb_gobp_nk` is a 'GeneSetCollection' object, contains genesets with gene-set name matched to 'NATURAL_KILLER' from <GO:BP> MSigDB v7.4 database. More details for `?mastR::msigdb_gobp_nk`.

- `NK_markers` dataset is a combination of CIBERSORT LM7, LM22 and human orthologs in mice from [Huntington](https://cancerimmunolres.aacrjournals.org/content/7/7/1162.long). It contains 114 genes in total.

The output of markers generation functions is either 'GeneSet' or 'GeneSetCollection' object.

## Generate Markers from Sources

To screen the immune cell subset signatures, we need to generate a markers pool first. mastR allows people to generate markers pool from multiple resources as metinoned before.

In this demo, we will load some example datasets to show how it works. The datasets used in this report have been built within the package or can be accessed publicly. You can use the following scripts to load them into the environment.

### i) LM

`LM7/LM22` is immune cells signature matrix from CIBERSORT, contains 7/22 immune cell subsets markers lists.

Markers can also be generated from LM7/22 signature matrix to get immune cells markers using function `get_lm_sig()`.

Users can extract markers for cell subsets matched to the given regex pattern from imported data `LM7`/`LM22`.

```{r LM markers}
data("LM7", "LM22")
## only retrieve LM7
get_lm_sig(lm7.pattern = "^NK")

## only retrieve LM22
# get_lm_sig(lm22.pattern = "NK cells")

## collect both LM7 and LM22
LM <- get_lm_sig(lm7.pattern = "^NK", lm22.pattern = "NK cells")
LM
```

By using `gsc_plot()`, an UpSetR plot across all gene-sets in the input would be printed. The input can be either 'GeneSet' or 'GeneSetCollection' objects. Using `gsc_plot()` we can see how different gene-sets intersect with each other.

```{r gsc plot}
## show upset diagram
gsc_plot(LM)
```

### ii) MSigDB

The Molecular Signatures Database (**MSigDB**) is a resource of tens of thousands of annotated gene sets for use with GSEA software, divided into Human and Mouse collections.

Gene-sets from MSigDB can also be searched and collected by using the function `get_gsc_sig()`.

All gene-sets with gene-set name matched to the regex `pattern` in the whole `gsc` would be extracted if `cat` and `subcat` are not set, otherwise only the genesets under the union of `cat` and `subcat` would be searched.

In this demo, we'll use a small collection of MSigDB `msigdb_gobp_nk` to show how it works.

```{r MSigDB genesets, warning=FALSE}
data("msigdb_gobp_nk")
MSig <- get_gsc_sig(gsc = msigdb_gobp_nk,
                    pattern = "NATURAL_KILLER_CELL_MEDIATED")
MSig
```

Then we can see how these collected gene-sets overlapped by using function `gsc_plot()`. We can see which gene-sets are the top 3 in the upset plot.

As the gene-set names are too long, for better visualization we replace the gene-set names with letters and show them later.

```{r show overlap}
## cut geneset name within 11 characters
gsn <- setNames(names(MSig), LETTERS[seq_along(MSig)])
for (i in seq_along(MSig)) {
  setName(MSig[[i]]) <- LETTERS[i]
}

## show upset diagram of collected gene-sets
gsc_plot(MSig)
gsn[c("A", "M", "D")]  ## show gene-set names of top 3
```

As we can see, there're `r length(MSig)` gene-sets in MSig, which is too many for visualization. Thus, we can use another function `merge_markers()` to merge all gene-sets into one 'GeneSet' object. (You can also directly pass un-merged object to the subsequent analysis.)

The input of `merge_markers()` can be a list of vectors of genes, or a list of GeneSet objects, or a GeneSetCollection object.

```{r merge MSigDB}
## merge all genesets into one
MSig <- merge_markers(MSig)
setName(MSig) <- "MSigDB"
```

***Note***: `data = "msigdb"` allows searching of MsigDB without loading it into the environment. `species` or `version` can also be set as optional params.

### iii) PanglaoDB

PanglaoDB is a database for the scientific community interested in exploration of single cell RNA sequencing experiments from mouse and human. It collects and integrates data from multiple studies and present them through a unified framework.

Markers from [PanlaoDB](https://panglaodb.se/) can be obtained to build the markers pool by using function `get_panglao_sig()`.

Users can use `list_panglao_organs()` and `list_panglao_types()` functions to list all available organs and cell types on PanglaoDB website and use `get_panglao_sig()` function to retrieve them.

We don't run it here as it requires the connection to the Internet.

```{r PanglaoDB markers, eval=FALSE}
## show availbable organs on PanglaoDB
list_panglao_organs()

## show available cell types of interest organ on PanglaoDB
## Number in the bracket represents the number of markers for each cell type (in both Homo and Mus).
list_panglao_types(organ = "Immune system")

## collect all "NK cells" markers from PanglaoDB website
Panglao <- get_panglao_sig(type = "NK cells")

Panglao
## number differs from 'NK cells' under list_panglao_types(organ = "Immune system"), because we only keep 'Hs' markers.
```

### iv) Customized gene list

`NK_markers` dataset is a combination of CIBERSORT LM7, LM22 and human orthologs in mice from Huntington generated by [Curson's Publication](https://aacrjournals.org/cancerimmunolres/article/7/7/1162/469488/A-Gene-Signature-Predicting-Natural-Killer-Cell). It contains 114 genes in total, which can be regarded as a customized gene list.

We can see how markers can be generated from a customized gene list.

```{r NK_markers}
## show what NK_markers looks like:
data("NK_markers")
NK_markers

## convert NK markers into 'GeneSet' object
nk_m <- GeneSet(NK_markers$HGNC_Symbol,
                geneIdType = SymbolIdentifier(),
                setName = "NK_markers")
```

## Pool Markers from Sources

Now we have multiple lists of markers from different sources, to use them in the subsequent analysis, we need to merge them together.

All markers can be merged into one 'GeneSet' object by using function `merge_markers()`.

```{r integrate markers}
gsc <- GeneSetCollection(c(nk_m, LM, MSig)) ## add Panglao if you run it
Markers <- merge_markers(gsc)

## upset plot
gsc_plot(gsc)

Markers
```

The source of each marker will be saved as a data.frame under the 'longDescription' slot of the output in json format. Users can view it to trace back the source of each gene.

```{r source table}
## to show the table summary of merged list
head(jsonlite::fromJSON(GSEABase::longDescription(Markers)))
```

Now with a large markers pool for screening, we need to screen signature genes from the pool for both cell subset and tissue specificity.

# Step 2. Signature Identification for Target Group

------------------------------------------------------------------------

For group specificity, there are 4 main steps:

  a)  differential expression (DE) analysis: filtration, normalization, sample weighting and linear model fit all done;  
  b)  feature selection: select differentially expressed genes with high ranks in most of comparisons using rank product score;  
  c)  constrain selected genes within the markers pool.

Customized external data is accepted in many formats: DGEList, eSet, matrix... For example, a large collection of 1561 bulk RNA-seq samples generated by DICE from pure populations of human immune cells, can be used as input data. It can be loaded by function `celldex::DatabaseImmuneCellExpressionData()`, which contains 5 main cell types and 15 fine cell types.

***Note***: all input data must be raw counts data or log-transformed expression data.

In this demo, we use our imported example data `im_data_6` from [GSE60424](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE60424) as input. Only samples from healthy individuals are kept, and 'Whole Blood' or 'PBMC' cells are removed in dataset. It can also be obtained by `GEOquery::getGEO()`.

`im_data_6` is a eSet object, containing RNA-seq TMM normalized counts data of 6 sorted immune cell subsets \* 4 samples. More details in `?mastR::im_data_6`.

```{r im_data_6}
data("im_data_6")
im_data_6
```

## a) processing the data {#process}

To screen signature for the group specificity, the data needs to be pre-processed which includes gene filtering, normalization etc..

`process_data()` in mastR does the End-to-End differential expression analysis using `edgeR` and `limma` pipeline as a single function call.

Users need to provide an expression data with sample group labels (containing interested target group), a `DGEList` object with filtered counts (unfiltered counts data will be saved under "original"), vfit (`limma::voom()` is done), tfit (`limma::lmFit()` and `limma::treat()` are done) will be returned.

Process under the hood:

- Data filtered by the given cutoff, all gene with low expression will be removed by edgeR.

- If the given data is raw count data (`normalize = TRUE`), further normalization 'TMM' and `limma::voom()` fit is conducted, otherwise `trend` of limma is applied.

- Final linear model is fitted.

- gene statistic for differential expression analysis are computed by `limma::treat()`.

Let's see what cell types are in `im_data_6`.

```{r type names}
table(im_data_6$`celltype:ch1`)
```

The following parameters are required by `process_data()`:

- `data`: can be a bulk RNA-seq expression object with cell subset labels, can be matrix, eSet, DGEList, ... (expression must be either raw counts or logcounts).
- `group_col`: can specify the column name of groups (labels), can be a vector when `data` is a matrix.
- `target_group`: can specify the cell target_group name of interest. Users can choose one name in `group_col` vector.
- `markers`: could specify a geneset to be kept no matter if they pass the filtration. Setting it to `NULL` can skip this. Must be gene SYMBOL ID.
- `gene_id`: specify the gene ID type of rownames of data when markers is not NULL, could be one of 'ENSEMBL', 'SYMBOL', 'ENTREZ'..., default 'SYMBOL'.

Optional param details can be found in `help(proc_data)`

```{r process data}
proc_data <- process_data(
  data = im_data_6,  
  group_col = "celltype:ch1",
  target_group = "NK", 
  markers = geneIds(Markers),
  gene_id = "ENSEMBL" ## rownames of im_data_6 is ENSEMBL ID
  # summary = TRUE ## if to show the summary of tfit result
)
# summary(limma::decideTests(proc_data$tfit))
```

As expression after `limma::voom()` is well normalized and log-transformed, it's better to save it under the `proc_data` for usage below.

```{r save voom E}
## add voom fitted expression as a new list of proc_data for use
proc_data$voomE <- proc_data$vfit$E
```

***Note:***

mastR provides visualization functions to compare the data before and after `process_data()` and see how well the QC has been carried out by using `plot_diagnostics()` and `plot_mean_var()`.

To assess the removal of the low quality genes, `plot_diagnostics()` can be used to show the expression distribution, RLE and MDS plots.


## b) signature selection based on differential expression {#selection}

Now we get processed data with differential expression (DE) statistic for each gene in each comparison, then the `proc_data` can be passed into `select_sig()` function for further genes selection based on the DE result using rank product score. Group specific signature is therefore determined.

`feature_selection`: Default "auto" will perform "rankproduct" and switch to "none" if the number of final "UP" (up-regulated genes) and "DOWN" (down-regulated genes) genes are < 5.

```{r select sig}
## get the same result as there's permutation test for rank product
set.seed(123)
sig_ct <- select_sig(proc_data)

head(sig_ct)
```

***Note:***

mastR also implementes an additional feature to further increase the discriminative power of the signature between the fairly similar groups.

By setting `keep.top` and `keep.group`, the top n DEGs of specified DE comparisons of similar groups can be kept, DEGs are ranked based on `Rank` param. For instance, if we want keep more distinguishable genes between NK and CD8+ T cells, we can set `keep.group = "CD8"` or `keep.group = "NK-CD8"` and use `keep.top = n` to specify how many top genes in that comparison should be kept.


***Tips:***

All above steps from \@ref(process) to \@ref(selection) for screening group signature can be done by one integrated function `get_degs()`.*

`get_degs()` function can filter low expression genes out from immune dataset, normalize and fit voom model to data if `normalize = TRUE`, then a processed data `proc_data` object and a differentially expressed `DEGs` GeneSetCollection ('UP' and 'DOWN') will be returned as output.

QC plots can also be shown at the same time by setting optional param `plot = TRUE`.


## c) constrain signature within markers pool {#intersect-pool}

After getting specific signature genes for the target group, only keep those DEGs which are also present in our markers pool `Markers`, to constrain the final signature wthin the interested gene list.

As we are only interested in up-regulated genes in NK cells in this demo, only `UP` DEGs are kept and intersected now.

Because the row names of `im_data_6` are ENSEMBL IDs while our markers from the sources are all gene SYMBOLs, we need to convert the IDs to the same type so that we can get the intersection.

```{r markers for cell type, fig.width=8, fig.height=6}
## convert ensembl IDs into symbols to match markers pool
deg_up <- mapIds(org.Hs.eg.db::org.Hs.eg.db,
                 geneIds(sig_ct[["UP"]]),
                 "SYMBOL", "ENSEMBL")
## markers specific for NK cells
m_ct <- intersect(geneIds(Markers), deg_up)
names(m_ct) <- names(deg_up)[match(m_ct, deg_up)]  ## set ensembl ID as names for downstream visualization

head(m_ct)
```

Use the visualizations like PCA to assess group separations.

In this case, PCA plots are used to show clearer separation of NK cells from other cells by using our screened UP DEGs. And the intersected genes with markers pool explain more variance in PC1 compared with non-intersected DEGs.

```{r PCA on sig}
## PCA shows clear separation of NK cells
## after intersection
pca_matrix_plot(proc_data[names(m_ct),],
                group_by = "celltype.ch1",
                slot = "voomE",
                n = 3) + ggtitle("Intersected UP DEGs")
## before intersection
pca_matrix_plot(proc_data[names(deg_up),],
                group_by = "celltype.ch1",
                slot = "voomE",
                n = 3) + ggtitle("All UP DEGs")
```

***Note***:

There's also a wrapper function `filter_subset_sig()` which can directly do the whole Step 2 in one step. The result would be the same as running the above workflow step by step.

`filter_subset_sig()` can also be helpful when you have multiple datasets (more details in Section \@ref(multi-data)). It can output final signature after aggregating signature lists from all datasets.


# Step 3. Signature Refinement by Background Expression in Tissue (optional)

------------------------------------------------------------------------

After screening signature for group specificity, we need to increase the tissue specificity by removing the background expressed genes from the signature now, what we need to do in this demo is to filter out all relevant cancer cell lines expressed genes:

In order to remove background noise from the marker genes, we utilized a signal-to-noise ratio (SNR) approach to filter out genes with low SNR values. Here the signal is the expression of signature in signal data and the noise is the expression of the signature in background data. This was done to eliminate genes that have similar expression patterns across the target group and background tissues, which may be due to non-specific expression or technical artifacts.

The SNR is calculated as the difference between the mean expression value of the group of interest and the mean expression value of the background group, divided by the standard deviation of the background group. Genes with low SNR values are considered to have low discriminative power between the group of interest and the background, and are therefore filtered out.

By removing genes with low SNR values, we are able to improve the specificity and accuracy of the marker genes, as well as reduce potential confounding effects caused by non-specific expression or technical artifacts. This approach is commonly used in gene expression analysis to improve the reliability of differential expression analysis and biomarker identification.

By doing this, we can guarantee the activity of our final signature for infiltrating immune cells won't be affected by tumor purity when it's applied on tumor samples.

mastR provides a `remove_bg_exp_mat()` function that can eliminate genes with strong signal in cancer cells or tissues, regarded as background expression. Users can input two datasets: one as the signal data (data for signature identification after process, `proc_data`) and the other as the background noise data (data of tissues or cancers of interest). Then, all genes with low SNR (signal to noise ratio) will be eliminated from the given markers list. This ensures that our immune signature remains unaffected by tumor purity.

***Note***: Both of signal data and background data should be log-normalized.

The signal data shoule always be the result generated by `process_data()` function.

## Remove Background Expressed Genes from Markers Pool

Based on the background data input format, mastR can be used in 2 ways:

- use CCLE as background data
- use customized data as background data

The Cancer Cell Line Encyclopedia (**CCLE**) is a compilation of gene expression, chromosomal copy number and massively parallel sequencing data from more than 1,000 human cancer cell lines.

### CCLE as cancer cell background data

If we use CCLE from [DepMap CCLE](https://depmap.org/portal/download/), containing RSEM quantified TPM data of 1392 cancer cell lines (until 2022.04), it can be downloaded and loaded by `depmap::depmap_TPM()`.

As the whole CCLE is quite large, we can use `ccle_crc_5` to construct a small pseudo CCLE data with similar format.

`ccle_crc_5` is a DGEList object only contains 5 CRC cell line samples from CCLE. More details for `help(ccle_crc_5)`.

```{r ccle construction}
data("ccle_crc_5")
ccle <- data.frame(ccle_crc_5$counts,
                   gene_name = rownames(ccle_crc_5),
                   primary_disease = "CRC") |> 
  tidyr::pivot_longer(-c(gene_name, primary_disease),
                      names_to = "depmap_id",
                      values_to = "rna_expression")

ccle
```

#### data subset

First we need to subset the cell lines of interest, which are regarded as background of our signature, and subset our signal data of the target group.

```{r subset sig and bg data}
## subset all NK cells of sig data
sig_mat <- proc_data$voomE[,proc_data$samples$celltype.ch1 == "NK"]
## subset CRC cell lines of bg data
ccle <- ccle[ccle$primary_disease == "CRC",]
```

#### ccle process

As CCLE data downloaded from `depmap::depmap_TPM()` is in long data format, and our `remove_bg_exp_mat()` can only accept matrix in wide format. To easily utilize the CCLE resource, mastR provides a function `ccle_2_wide()` to help do the conversion.

```{r ccle to wide mat}
ccle <- ccle_2_wide(ccle = ccle)

ccle[1:3, 1:3]
```

Because we use scaled expression to compute SNR, we need to remove low expression genes before scaling. `sig_mat` from `proc_data` has already been filtered, so we only need to do the filtration on ccle.

As we only have 5 samples in `ccle`, we only keep the genes with logTPM > 1 within more than 2 cell lines.

```{r ccle filtration}
## set cutoff for filtration
filter <- c(1, 2)
keep <- rowSums(ccle > filter[1], na.rm = TRUE) > filter[2]
ccle <- ccle[keep,]
```

#### markers pool filtration

Now we get 2 matrices for signal and background data, then we can use `remove_bg_exp_mat()` to refine the markers pool.

`remove_bg_exp_mat()` removes genes which are highly expressed in corresponding disease cell lines (in this case CRC adherent cell lines). This removes tumor purity as a factor in the identified signature markers.

As markers and row names of `ccle` are gene SYMBOLs while `sig_mat` has ENSEMBL IDs as row names, we need to convert them into the same type. mastR provides the gene ID conversion feature in most of the in-built functions, users can specify the gene ID types using parameter `gene_id`, the 1st element will be used as the ID type of signal data, and the 2nd one will be used for background data.

***Note***: Both of `bg_mat` and `sig_mat` should be log-normalized.

```{r remove bg in ccle}
m_ccl <- remove_bg_exp_mat(
  sig_mat = sig_mat,
  bg_mat = ccle,
  markers = geneIds(Markers),
  gene_id = c("ENSEMBL", "SYMBOL")
)

head(m_ccl)
```

### customized dataset as background data

If the background data is customized data from other sources, we only need to subset data, filter low expression genes and remove markers from pool.

In this demo, we still use the small imported dataset `ccle_crc_5` in mastR as a customized dataset.

#### data subset

Now we already get both matrices for signal and background data, so we can directly do the subsetting on the matrices.

```{r subset customized bg data}
## subset all NK cells of sig data
sig_mat <- proc_data$voomE[,proc_data$samples$celltype.ch1 == "NK"]
## subset CRC cell lines of bg data
bg_mat <- ccle_crc_5$counts[, ccle_crc_5$samples$cancer == "CRC"]
```

#### data filtration

Now we have both subset of matrices, the next steps will be the same as using CCLE. So we use the same filtration cutoff here.

```{r bg data filtration}
keep <- rowSums(ccle > filter[1], na.rm = TRUE) > filter[2]
bg_mat <- bg_mat[keep,]
```

#### markers pool filtration

As we use the same dataset to construct `ccle`, the final result will be the same.

```{r remove bg in customized}
m_ccl <- remove_bg_exp_mat(
  sig_mat = sig_mat,
  bg_mat = bg_mat,
  markers = geneIds(Markers),
  gene_id = c("ENSEMBL", "SYMBOL")
)

head(m_ccl)
```


## Combine with Signature

After above steps, now we need to combine the result with the signature we get from Step 2.

As we want the final signature to be specific to the target cell subset while less affected by the tissue/cancer purity, intersection is preferred to select the final signature after Step 2: cell type (group), and Step 3: cancer (tissue) type.

```{r final signatures}
sig_NK_CRC <- intersect(m_ct, m_ccl)
head(sig_NK_CRC)
```

But here, if we directly use the `m_ct` instead of `Markers` as input `markers` for function `remove_bg_exp_mat()`, then `m_ccl` is already the intersection result of original `m_ccl` and `m_ct`, so we can skip this.

Now we get the final signature specific for both cell type and cancer type!

***Note:***

The whole Step 3 can be done by the wrapper function `remove_bg_exp()` in mastR. It does subsetting, filtration and removal in one single function call. More details can be found in `help(remove_bg_exp)`.

# Step 4. Visualization of Screening Results

------------------------------------------------------------------------

Now we assess how well the refined signature can discriminate our target group from others. mastR provides the following visualization functions for different purposes:

- `pca_matrix_plot()` for matrix of PCA plots with top n PCs.
    To show if the target group can be separated from other groups and how well the separation is. Users can also know how much variance has been explained by PC1 with the signature.

- `sig_heatmap()` for signature heatmap across groups and its comparsion with markers pool.
    To validate if the signature shows clear and differential expression pattern between the target group and others, and if the pattern is clearer and cleaner after the screening when compared with un-screeed markers pool.

- `sig_rankdensity_plot()` for signature genes rank density distribution across groups.
    To see if the signature genes are highly expressed within each sample of the target group while lowly expressed in others.

- `sig_boxplot()` for signature expression or singscore boxplot across groups.
    To test the overall performance of the whole signature when applying it for scoring, singscore is used to compute the rank score with the whole signature. The boxplot across groups can be used to test if the whole signature is powerful enough to distinguish the target group from others on scoring level. Median expression of each signature gene is also allowed to plot.

- `sig_scatter_plot()` for signature scaled expression scatter plot of the target group vs all other groups respectively.
    To visualize the correlation of the signature between the target and other groups, the row-scaled gene expression is computed to make the scatter plot. Based on it, we can easily see the co-expression correlation and signature's specificity.

- `sig_gseaplot()` for gene-set enrichment analysis result display.
    To further validate if the signature is significantly enriched in our target group compared with other groups, `clusterProfiler::GSEA()` analysis is done inside this function. Users can choose to display 'dotplot' or gseaplot' by `clusterProfiler::GSEA()`.


## Heatmap

`sig_heatmap()` function can plot the original NK cells markers and curated signatures expression pattern heatmaps in immune datasets.

- `sigs`: the final curated signature symbols (or list of multiple signatures).
- `markers`: is the original markers pool (optional).
- `scale`: specify the `column` or `row` to be scaled or no scaling by `none`.

```{r heatmap, warning=FALSE, fig.width=10, fig.height=7}
sig_heatmap(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  markers = geneIds(Markers),
  gene_id = "ENSEMBL",
  slot = "voomE",
  scale = "row",
  show_column_den = FALSE,
  show_row_den = FALSE,
  show_column_names = FALSE,
  show_row_names = FALSE
)

## for multiple datasets
# sig_heatmap(
#   data = list(data_6 = im_data_6,
#               proc_data = proc_data), 
#   sigs = sig_NK_CRC,
#   group_col = c("celltype:ch1", "celltype.ch1"), 
#   markers = geneIds(Markers),
#   gene_id = "ENSEMBL"
# ) + patchwork::plot_layout(guides = "collect", ncol = 1)
```

We can see the expression pattern of the signature is more distinguishable in NK cells.


## Signature Score Boxplot

To see if the curated signature have evident higher abundance in NK cells than other immune cell subsets, use `sig_boxplot()` function to make a boxplot of NK scores for all cell subsets in the data. NK score is calculated by `singscore` package.

***Note***: Boxplot of median expression of each gene can be plotted by setting param `type = "expression"`.

```{r score boxplot, warning=FALSE}
sig_boxplot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  target_group = "NK", 
  gene_id = "ENSEMBL",
  slot = "voomE"
)

## To make boxplots for more than 1 immune datasets at once:
# sig_boxplot(
#   data = list(data_6 = im_data_6,
#               proc_data = proc_data), 
#   sigs = sig_NK_CRC,
#   group_col = c("celltype:ch1", "celltype.ch1"),
#   target_group = "NK",
#   gene_id = "ENSEMBL"
# ) * guides(col = "none")
```

Obviously, our signature shows significantly higher score in NK cells.


## Signature Abundance Scatter Plot

To see if the curated signature shows higher specificity to NK cells than other immune cell subsets. Use `sig_scatter_plot()` function to make scatter plot of the signature scaled abundance for all cell subsets in the data.

If the signature shows specificity to NK, then most of signature genes should appear in left-top region (scaled expression > 1 in NK, < 1 in other), while the gene present in right-top region should represent the co-expression in the both groups.

```{r abundance scatter plot, warning=FALSE, fig.width=8, fig.height=5}
## before refinement
sig_scatter_plot(
  data = proc_data,
  sigs = geneIds(Markers),
  group_col = "celltype.ch1", 
  target_group = "NK",
  gene_id = "ENSEMBL",
  slot = "voomE"
)

## after refinement
sig_scatter_plot(
  data = proc_data,
  sigs = sig_NK_CRC,
  group_col = "celltype.ch1", 
  target_group = "NK",
  gene_id = "ENSEMBL",
  slot = "voomE"
)

## To make scatter plot for more than 1 immune datasets at once:
# sig_scatter_plot(
#   data = list(data_6 = im_data_6,
#               proc_data = proc_data), 
#   sigs = sig_NK_CRC,
#   group_col = c("celltype:ch1", "celltype.ch1"),
#   target_group = "NK", 
#   gene_id = "ENSEMBL")
```

Based on scatter plot result, we can actually do further filtration to improve signature specificity by removing signature genes present in right bottom or left bottom region.

## Signature GSEA plot

To see if the curated signature is enriched in NK cells than other immune cell subsets. Use `sig_gseaplot()` function to make GSEA plot. Dotplot can be plotted by setting `method = "dotplot"`.

```{r gseaplot, warning=FALSE, fig.width=10, fig.height=7}
## gseaplot
sig_gseaplot(
  data = proc_data, 
  sigs = list(sig = sig_NK_CRC, markers = geneIds(Markers)),
  group_col = "celltype.ch1", 
  target_group = "NK",
  gene_id = "ENSEMBL",
  slot = "voomE",
  method = "gseaplot"
)
```

It's clear that our refined signature is enriched in all comparisons, and our refinement successfully removed the long tail from the markers pool.


# Working with Extension Data Input

## Multiple Datasets {#multi-data}

------------------------------------------------------------------------

Till now, the whole workflow of mastR usage is complete.

But this demo is just a show case on single dataset, mastR can also be applied on multiple datasets.

After the Step 2d (Section \@ref(intersect-pool)), for:

1) single dataset  
    Return the intersection result as the signature.

2) multiple datasets  
    After Step 2d, choose one combination method (`union` default) to aggregate signature lists generated from different datasets. Robust Rank Aggregation ("RRA") is another method to select in mastR, which detects genes that are ranked consistently better than expected under null hypothesis of uncorrelated inputs and assigns a significance score for each gene.

Instead of integrating datasets into one larger dataset to fit into one linear model, we screen signature in each dataset respectively and users can choose to aggregate the ranked lists via `RobustRankAggreg` method by setting `comb = "RRA"` (as our output of signature by screening function is ordered based on the given `Rank`).

The advantage is that we can avoid over-normalizing or mis-correcting when carrying out data integration. And we can get more robust and conserved signature across datasets. It's better than "RemoveBatchEffect" sometimes.

Of course, easy way such as "union" and "intersect" is also supported besides "RRA" (Robust Rank Aggreg), by setting `comb = union` or `comb = intersect`.

It's better to use union when you get only a few genes screened for each dataset, while "RRA" is better to pick up significant genes from large DEG lists, "intersect" is proper for highly overlapping gene lists.

Here, we will repeatedly use im_data_6 to show how it works on multiple datasets.

```{r screen multiple datasets, eval=FALSE}
## In the demo, we just repeatedly use im_data_6 as a show case
set.seed(123)
m_ct_m <- filter_subset_sig(
  data = list(A = im_data_6, B = im_data_6), 
  markers = geneIds(Markers),
  group_col = "celltype:ch1",
  target_group = "NK",
  dir = "UP", ## specify to keep "UP" or "DOWN" regulated genes
  gene_id = "ENSEMBL"
)

## we will get exactly the same list
## if we choose 'union' or 'intersect' as combination
setequal(m_ct_m, m_ct)

## but we will only get the genes appear at top rank across gene lists
## if we choose 'RRA', s_thres is to determine the threshold for ranking score
set.seed(123)
m_ct_m <- filter_subset_sig(
  data = list(A = im_data_6, B = im_data_6), 
  markers = geneIds(Markers),
  group_col = "celltype:ch1",
  target_group = "NK",
  # dir = "UP", ## specify to keep "UP" or "DOWN" regulated genes
  gene_id = "ENSEMBL",
  comb = "RRA",  ## change this to use different strategy, default is "union"
  s_thres = 0.5  ## only work when comb = "RRA", set a threshold for ranking score
)

## we can get only 8 signature genes this time
m_ct_m
```

## Single Cell RNA-sequencing Data

------------------------------------------------------------------------

Although mastR is developed for bulk RNA data, to make use of abundant scRNA resource, mastR also provides `pseudo_samples()` function to help convert scRNA data into pseudo-bulk data, which can then be used in the above workflow.

`pseudo_samples()` can help aggregate cells into pseudo-sample according to the given factor(s).

```{r pseudo-bulk, eval=FALSE}
## create a test scRNA object of 100 genes x 100 cells
counts <- matrix(abs(rpois(10000, 10)), 100)
rownames(counts) <- 1:100
colnames(counts) <- 1:100
meta <- data.frame(
  subset = rep(c("A", "B"), 50),
  level = rep(1:4, each = 25)
)
rownames(meta) <- 1:100
pb <- pseudo_samples(counts, by = meta)

pb <- edgeR::DGEList(counts = pb, group = gsub("\\..*", "", colnames(pb)))

filter_subset_sig(pb, group_col = "group", target_group = "A")

## Seurat or SCE object are also accepted
# scRNA <- Seurat::CreateSeuratObject(counts = counts, meta.data = meta)
# pseudo_samples(scRNA, by = c("subset","level"))
```

# Applications {.tabset .tabset-fade .tabset-pills}

After getting the signature, we can apply it in multple ways. In this short demo, we will just show 3 simple applications of it.

Here we will simulate a scRNA data using `splatter`. Then randomly pseudo-bulking it to generate pseudo bulk data for scoring and deconvolution.

```{r simulation, eval=FALSE}
library(splatter)
## set seed for reproduce as there's permutation inside
set.seed(123)

sim_params <- newSplatParams(
  nGenes = 1000,
  batchCells = 3000,
  group.prob = seq(0.1, 0.4, length.out = 4),
  de.prob = 0.02,
  # de.downProb = 0,  ## only set up-regulated genes for each group
  de.facLoc = 0.5,
  de.facScale = 0.4
)

data_sim <- splatSimulate(sim_params, method = "groups")

markers_list <- lapply(rowData(data_sim)[,paste0("DEFacGroup", 1:4)],
                       \(x) rownames(data_sim[x > 1]))

## aggregate into pseudo-bulk samples
pb <- pseudo_samples(data_sim,
                     by = c("Batch", "Group"),
                     min.cells = 50, max.cells = 100)
dge <- DGEList(
  counts = pb,
  samples = data.frame(group = gsub(".*\\.(.*)_.*", "\\1",colnames(pb)),
                       Batch = gsub("(.*)\\..*", "\\1",colnames(pb)),
                       sampleID = gsub("(.*)_.*", "\\1",colnames(pb)))
)
```

```{r get sigs, eval=FALSE, fig.height=4}
set.seed(123)
sig_ls <- lapply(paste0("Group", 1:4), \(x) {
  filter_subset_sig(
    data = dge,
    markers = NULL,
    group_col = "group",
    target_group = x,
    lfc = 0
  )
})
names(sig_ls) <- paste0("Group", 1:4)

## venn plot
p <- lapply(1:4, \(i) ggvenn::ggvenn(list(sig = sig_ls[[i]],
                                          marker = markers_list[[i]]),
                                     show_percentage = FALSE) +
              ggtitle(names(sig_ls)[i]))
patchwork::wrap_plots(p)

## heatmap
sig_heatmap(
  cpm(dge, log = TRUE),
  sigs = c(sig_ls, list("TP53")), ## add a real gene to pass gene check
  group_col = dge$samples$group,
  scale = "row",
  show_column_den = FALSE,
  show_row_den = FALSE,
  cluster_column_slices = FALSE,
  cluster_row_slices = FALSE
)
```

```{r random pseudo-bulk, eval=FALSE}
library(dplyr)
## randomly generate aggregating idx
set.seed(123)
data_sim$rand_idx <- sample.int(30, ncol(data_sim), replace = TRUE)

## aggregate into pseudo-bulk samples based on rand_idx
pb_r <- pseudo_samples(data_sim, by = c("Batch", "rand_idx"))
dge_r <- DGEList(
  counts = pb_r,
  samples = data.frame(group = gsub(".*\\.(.*)_.*", "\\1",colnames(pb_r)),
                       Batch = gsub("(.*)\\..*", "\\1",colnames(pb_r)),
                       sampleID = gsub("(.*)_.*", "\\1",colnames(pb_r)))
)

## append cellular composition
tmp <- as.data.frame(data_sim@colData) |>
  group_by(rand_idx, Group) |>
  summarise(count = n()) |>
  pivot_wider(names_from = Group, values_from = count) |>
  mutate(rand_idx = factor(rand_idx))
tmp[,-1] <- signif(tmp[,-1] / rowSums(tmp[,-1]), 2)
dge_r$samples <- left_join(dge_r$samples, tmp, by = c("group" = "rand_idx"))

## data process
keep <- filterByExpr(dge_r)
dge_r <- dge_r[keep,, keep.lib.sizes = FALSE]
dge_r <- calcNormFactors(dge_r, method = "TMM")
```

## Score

```{r score, eval=FALSE}
library(singscore)

rank_data <- rankGenes(edgeR::cpm(dge_r, log = TRUE))

## score based on sig_ls
scores <- multiScore(rank_data, upSetColc = gls2gsc(sig_ls))

tmp <- pivot_longer(cbind(Sample = colnames(dge_r), dge_r$samples[,6:9]),
                    -Sample, names_to = "Group", values_to = "Prop")

tmp <- t(scores$Scores) |> 
  data.frame(Sample = colnames(scores$Scores)) |> 
  pivot_longer(-Sample, names_to = "Group", values_to = "Score") |> 
  left_join(tmp)

ggplot(tmp, aes(x = Prop, y = Score, col = Group)) +
  geom_point() +
  facet_wrap(~Group, scales = "free") +
  ggpubr::stat_cor() +
  theme_classic()

## score based on markers_list
scores <- multiScore(rank_data, upSetColc = gls2gsc(markers_list))

tmp <- pivot_longer(cbind(Sample = colnames(dge_r), dge_r$samples[,6:9]),
                    -Sample, names_to = "Group", values_to = "Prop")
tmp$Group <- paste0("DEFac", tmp$Group)

tmp <- t(scores$Scores) |> 
  data.frame(Sample = colnames(scores$Scores)) |> 
  pivot_longer(-Sample, names_to = "Group", values_to = "Score") |> 
  left_join(tmp)

ggplot(tmp, aes(x = Prop, y = Score, col = Group)) +
  geom_point() +
  facet_wrap(~Group, scales = "free") +
  ggpubr::stat_cor() +
  theme_classic()
```

## Deconvolution

```{r deconv, eval=FALSE}
sig_matrix <- DWLS::buildSignatureMatrixMAST(
  scdata = data_sim@assays@data$counts[unique(unlist(sig_ls)),],
  id = data_sim$Group,
  path = tempdir()
)

res <- DWLS::solveDampenedWLS(sig_matrix, pb_r[rownames(sig_matrix),])
```

## Annotation

```{r annotation, eval=FALSE}
library(singscore)
## normalization
data_sim <- scuttle::computePooledFactors(data_sim, clusters = data_sim$Group)
data_sim <- scuttle::logNormCounts(data_sim)
## use singscore for annotation
rank_data <- rankGenes(data_sim@assays@data$logcounts)

## score using sig_ls
scores <- multiScore(rank_data, upSetColc = gls2gsc(sig_ls))
data_sim$Pred <- paste0("Group", apply(scores$Scores, 2, which.max))
table(data_sim$Pred == data_sim$Group)

## score using markers_list
scores <- multiScore(rank_data, upSetColc = gls2gsc(markers_list))
data_sim$Pred <- paste0("Group", apply(scores$Scores, 2, which.max))
table(data_sim$Pred == data_sim$Group)
```

# Session Info

------------------------------------------------------------------------

```{r session info}
sessionInfo()
```

