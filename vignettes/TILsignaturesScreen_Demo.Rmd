---
title: "mastR_Demo"
author:
  - name: Jinjin Chen
    affiliation:
      - Bioinformatics Division, Walter and Eliza Hall Institute of Medical Research, Parkville, VIC 3052, Australia
      - Department of Medical Biology, University of Melbourne, Parkville, VIC 3010, Australia
    email: chen.j@wehi.edu.au
date: "`r format(Sys.time(), '%d %b %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{mastR_Demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

-----------------------------

This report demonstrates how to use the functions in R package `mastR 0.1.0` to screen immune subset signatures in specific tissue and visualize the effects of the curation.

`mastR` is developed to screen immune cells signature in cancer tissues. So there are several datasets imported into this package for running by default. But users could specify other immune subsets and other tissues by setting the parameters in the R functions. Next, this report will show how the workflow runs to refine NK cells signatures which are specific for CRC, and how to visualize the results effect.

# Installation

-----------------------------

Install `mastR` R package from [GitHub](https://github.com/Gene233/mastR).
The most updated version of `mastR` is hosted on GitHub and can be easily installed using `devtools::install_github()` function provided by [devtools](https://cran.r-project.org/package=devtools).

```{r installation, eval=FALSE}
# if (!requireNamespace("devtools", quietly = TRUE)) {
#   install.packages("devtools")
# }
# if (!requireNamespace("mastR", quietly = TRUE)) {
#   devtools::install_github("Gene233/mastR")
# }

if (!requireNamespace("BiocManager", quietly=TRUE)) {
  install.packages("BiocManager")
}
if (!requireNamespace("mastR", quietly = TRUE)) {
  BiocManager::install("mastR")
}
```

# Prepare Immune Markers Pool

------------------------------

## Load Datasets

To screen the immune subset signatures, we have to load the example datasets. The datasets used in this report have been built within the package or can be accessed publicly. You can use the following scripts to load them into your R environment.

`NK_markers` dataset is a combination of CIBERSORT LM7, LM22 and human orthologs in mice from [Huntington](https://cancerimmunolres.aacrjournals.org/content/7/7/1162.long). It contains 114 genes in total.

`LM7` and `LM22` are signature matrices, you can get more details by `?mastR::LM7` or `?mastR::LM22`.

`im_data_6` is a eSet object, containing RNA-seq TMM normalized counts data of 6 sorted immune subsets. More details in `?mastR::im_data_6`.

```{r setup}
library(mastR)
library(ggplot2)
```

### NK markers from [Curson's Publication](https://aacrjournals.org/cancerimmunolres/article/7/7/1162/469488/A-Gene-Signature-Predicting-Natural-Killer-Cell)

```{r NK_markers}
## show what NK_markers looks like:
NK_markers
```

### Markers from LM

Uses can extract markers for subsets matched to the given pattern from imported data `LM7`/`LM22`. 

The matched genes will be saved in 'GeneSet' class object, if both pattern are provided, the output would be a 'GeneSetCollection' class object with setName: LM7, LM22.

```{r LM markers}
## only retrieve LM7
get_lm_sig(lm7.pattern = "NK")

## only retrieve LM22
get_lm_sig(lm22.pattern = "NK cells")

## collect both LM7 and LM22
LM <- get_lm_sig(lm7.pattern = "NK", lm22.pattern = "NK cells")

LM
```

### Markers from MSigDB

The users can specify the `species`, `cat`, `subcat` and `pattern` to decide which genesets to be added. 

All genesets with geneset name matched to the `pattern` in the whole MSigDB would be extracted if `cat` and `subcat` are not set, otherwise only the genesets under the union of `cat` and `subcat` would be searched. 

By setting `plot = TRUE`, an UpSetR plot across matched genesets would be printed.

```{r MSigDB genesets, fig.width=12, warning=FALSE}
## collect all "natural killer mediated" relavent genesets from MSigDB
MSig <- get_msigdb_sig(pattern = "NATURAL_KILLER_CELL_MEDIATED",
                       subcat = "GO:BP", version = '7.4',
                       plot = TRUE)

MSig
```

### Markers from PanglaoDB

Users can use `list_panglao_organs()` and `list_panglao_types()` functions to list all available organs and cell types on PanglaoDB website and use `get_panglao_sig()` function to retrive them.

```{r PanglaoDB_NK}
## show availbable organs on PanglaoDB
list_panglao_organs()

## show available cell types of interest organ on PanglaoDB
## Number in the bracket represents the number of markers for each cell type (in both Homo and Mus).
list_panglao_types(organ = "Immune system")

## collect all "NK cells" markers from PanglaoDB website
Panglao <- get_panglao_sig(type = "NK cells")

Panglao
## number differs from 'NK cells' under list_panglao_types(organ = "Immune system"), because we only keep 'Hs' markers.
```

## Integrate Markers Pool

Finally, all markers can be merged into one 'GeneSet' object by using function `merge_markers()`.

The input can be a list of vectors of genes, or a list of GeneSet objects, or a GeneSetCollection object. `plot = TRUE` requires the list to have > 1 elements.

```{r integrate markers}
Markers <- merge_markers(markers_list = list(
  NK_markers = NK_markers$HGNC_Symbol |> 
    GeneSet(geneIdType = SymbolIdentifier(), setName = "NK_markers"),
  LM7 = LM[["LM7"]],
  LM22 = LM[["LM22"]],
  MSigDB = MSig,
  PanglaoDB = Panglao
  ), 
  plot = TRUE)

## can also use on GeneSetCollection
# merge_markers(markers_list = LM, plot = TRUE)

Markers

## to show the table summary of merged list
jsonlite::fromJSON(GSEABase::longDescription(Markers))
```

# Screen Immune Subset Signatures

------------------------------------

## Specify Markers Against Other Immune Subsets {.tabset .tabset-fade .tabset-pills}

You can use `celldex::DatabaseImmuneCellExpressionData()` to load a large collection of 1561 bulk RNA-seq samples generated by DICE from pure populations of human immune cells. It contains 5 main cell types and 15 fine cell types. Here to save time, we use our example data `im_data_6` as input.

The example uses `im_data_6` from [GSE60424](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE60424).

* `im_data_6` consists 6 immune subsets * 4 samples, the data type is 'TMM normalized counts data'.

Only samples from healthy individuals are kept, and 'Whole Blood' or 'PBMC' cells are removed in dataset.

```{r im_data_6}
im_data_6

edgeR::DGEList(
  counts = exprs(im_data_6),
  samples = pData(im_data_6)
)[["samples"]][, c(
  "lib.size", "donorid.ch1", "smoker.ch1",
  "cellcount.ch1", "collectiondate.ch1",
  "celltype.ch1", "gender.ch1"
)]
```

To find the passing genes, low expression genes filtration needs to be done first. `get_degs()` function can filter low expression genes out from immune dataset, generate a filtered `proc_data` object and return a differentially expressed genes list ('UP' and 'DOWN').

* `data` param can be a bulk RNA-seq expression object with subset labels, can be matrix, eSet, DGEList, ...  
* `ID` param can specify the column name of groups (labels), can be a vector when `data` is a matrix.  
* `type` param can specify the cell type name of interest. Users can choose one name in `ID` vector.  
* `count` param indicates if the input data is raw counts data. If `counts = FALSE`, the function would directly use the expression data *per se* to filter out genes instead of calculating CPM.  
* `method` param to choose whether to use rank product ('RP') or 'Group' for multiple comparisons for DE analysis, default 'RP'.  
* `plot = TRUE` would visualize the QC results before and after filtration. It would make log hist plot, RLE plot, MDS plot and SA plot.  
* `markers` param could specify a geneset to be kept no matter if they pass the filtration. Setting it to `NULL` can skip this.  
* `gene_id` specify the gene ID type of rownames of data when markers is not NULL, could be one of 'ENSEMBL', 'SYMBOL', 'ENTREZ'..., default 'SYMBOL'.

```{r type names}
im_data_6$`celltype:ch1` |> unique()
```

Get DEGs from immune datasets based on rank-product method.

```{r DEG_6}
DEG_6 <- get_degs(
  data = im_data_6,  
  ID = "celltype:ch1", type = "NK", 
  plot = TRUE, ## show QC plots after filtration
  markers = geneIds(Markers), 
  gene_id = "ENSEMBL"  ## convert ensembl IDs of rownames into symbols if gene_id != "SYMBOL"
)  
## `proc_data` object would be saved, saved expr after limma::voom pipeline.
proc_data <- DEG_6$proc_data

DEG_6[["UP"]] |> head()
DEG_6[["DOWN"]] |> head()
design <- model.matrix(~ 0 + factor(proc_data$samples$group))
colnames(design) <- levels(factor(proc_data$samples$group))
rownames(design) <- colnames(proc_data)
design  ## show the design matrix
```

Then we will only keep those UP regulated genes which are also in our markers pool `Markers`.

There's a wrapped function `filter_subset_sig()` which can directly do this from raw data. The result would be the same as run the workflow separately

```{r markers for cell type}
library(org.Hs.eg.db)
## convert ensembl IDs into symbols to match markers pool
deg_up <- mapIds(org.Hs.eg.db, DEG_6$UP, "SYMBOL", "ENSEMBL")
## markers specific for NK cells
m_ct <- intersect(geneIds(Markers), deg_up)
names(m_ct) <- names(deg_up)[match(m_ct, deg_up)]  ## set ensembl ID as names for downstream visualization

## run by wrapped function in one-step
m_ct_new <- filter_subset_sig(data = im_data_6, 
                              markers = geneIds(Markers),
                              ID = "celltype:ch1",
                              type = "NK",
                              gene_id = "ENSEMBL")

setequal(m_ct, m_ct_new)
```

We can see PCA shows clearer separation between NK cells and other cells by using screened UP DEGs, compared with all genes.

And compared with edgeR normalization only, data after voom can explain more variance in PC1 between NK cells and others, indicating stronger power for cell type discrimination.

```{r PCA for im_data_6, fig.width=10, fig.height=7}
## PCA on raw counts data with standard edgeR normalization
pca_matrix_plot(im_data_6, group_by = "celltype:ch1", 
                counts = TRUE)
pca_matrix_plot(im_data_6[names(m_ct),], group_by = "celltype:ch1", 
                counts = TRUE)

## PCA on limma::voomed data after standard edgeR normalization
pca_matrix_plot(proc_data, group_by = "celltype.ch1", 
                counts = FALSE)
pca_matrix_plot(proc_data[names(m_ct),], group_by = "celltype.ch1", 
                counts = FALSE)
## PCA show smaller PC1 variance without intersect with markers pool
pca_matrix_plot(proc_data[DEG_6$UP,], group_by = "celltype.ch1", 
                counts = FALSE)
```


## Specify Markers Against Tissue

The example uses `CCLE_tpm` from [DepMap CCLE](https://depmap.org/portal/download/), containing RSEM quantified TPM data of 1392 cancer cell lines (until 2022.04).

```{r CCLE_tpm}
CCLE <- depmap::depmap_TPM()
CCLE_meta <- depmap::depmap_metadata()

CCLE[1:10,]
```

To specify NK markers for CRC, use `filter_non_tissue()` function to remove failing genes which are also highly expressed by CRC adherent cell lines *per se*. This function would also generate `CCLE_tpm_new` object, extracting all `type` relevant cell lines.

* `type` param is an expression pattern to specify the tissue of interest, here we choose 'colorectal' to select all colorectal adherent cell lines.  
* `ignore.case` means whether to ignore the capital or not.  
* `log = TURE` would do log transformation to the data.  
* `q` param is the threshold to remove failing genes. 0.25 means removing markers with median expression >= 25% percentile of non-zero expression of all genes.  
* `markers` param is the updated markers pool.

```{r markers for cancer cell line}
## convert CCLE from long to wide data format
CCLE <- tidyr::pivot_wider(CCLE[,c("gene_name", "cell_line", "rna_expression")],
                           names_from = "cell_line",
                           values_from = "rna_expression") |> data.frame()
rownames(CCLE) <- CCLE$gene_name
CCLE$gene_name <- NULL

## match depmap ID of CCLE TPM to CCLE meta to get disease names
idx <- match(colnames(CCLE), CCLE_meta$cell_line)
cell_lines <- CCLE_meta$primary_disease[idx]

## markers against for CRC cell lines
m_ccl <- filter_non_tissue(data = CCLE,
                           ID = cell_lines,
                           type = "colorectal",
                           markers = geneIds(Markers))
## as CCLE is default setting, this can also be easily run without loading CCLE
# m_ccl <- filter(type = "colorectal",
#                 markers = geneIds(Markers))

head(m_ccl)
```

## Final NK Cells Signature for CRC

Select the Signature which pass both criteria: cell type and cancer cell line.

```{r final signatures}
sig_NK_CRC <- intersect(m_ct, m_ccl)
sig_NK_CRC
```

# Visulize The Curation Effect {.tabset .tabset-fade .tabset-pills}

----------------------------------

## PCA matrix plot

To see if curated NK cells signatures have more distinguishable expression pattern from other immune subsets, we can use PCA plot again here to show it.

Loading can be drawn to show which genes are relevant to NK cells, and result shows most of signature genes are indicating NK cells.

```{r pca, fig.width=10, fig.height=7}
## as proc_data shows better discrimination, use it for visualization
pca_matrix_plot(
  data = proc_data, 
  features = sig_NK_CRC, 
  counts = FALSE,
  group_by = "celltype.ch1",
  gene_id = "ENSEMBL"
)

## loadings can be shown by setting loading = TRUE
pca_matrix_plot(
  data = proc_data, 
  features = sig_NK_CRC, 
  loading = TRUE,
  counts = FALSE,
  group_by = "celltype.ch1",
  gene_id = "ENSEMBL"
)
```


## Heatmap

`result_heatmap()` function can plot the original NK cells markers and curated signatures expression pattern heatmaps in immune datasets.

* `sigs` param is the final curated signature symbols, while `markers` param is the original markers pool.  
* `scale` could specify the `column` or `row` to be scaled or no scaling by `none`.  
* `min_max` is used to decide if to apply min-max normalization to each row of expression data.
* `counts` means whether to calculate logCPM or not.    
* Users are able to specify the color of heatmap by setting `color` param.


We can see the expression pattern of cutrated signature is more distinguishable in NK cells.

```{r heatmap, fig.width=12, warning=FALSE}
sig_heatmap(
  data = proc_data, 
  sigs = sig_NK_CRC,
  counts = FALSE,
  ID = "celltype.ch1", 
  markers = geneIds(Markers),
  gene_id = "ENSEMBL"
)

## for multiple datasets
sig_heatmap(
  data = list(data_6 = im_data_6,
              proc_data = proc_data), 
  sigs = sig_NK_CRC,
  ID = c("celltype:ch1", "celltype.ch1"), 
  markers = geneIds(Markers),
  counts = c(TRUE, FALSE),
  gene_id = "ENSEMBL",
  col = colorRampPalette(c(rgb(1, 1, 0), "red"))(256)  ## can customize heatmap color
)
```


## Rank Density Plot

Use `sig_rankdensity_plot()` function to make rank density plot for all subsets in the data.

By setting `aggregate = TRUE`, only one plot for each cell type with mean expression would be shown.

We might want to see the rank density plot in more than 1 datasets for comparison, this can be done by simply passing a list of datasets to function.

We can find, processed data shows more digstinguishable rankdensity distribution of screened NK signature genes.

```{r rankdensity plot, fig.width=12, fig.height=8, warning=FALSE, results='hide'}
## visualization on both original and processed data
sig_rankdensity_plot(
  data = list(im_data_6 = im_data_6,
              process_Data = proc_data), 
  sigs = sig_NK_CRC,
  counts = c(TRUE, FALSE),
  ID = c("celltype:ch1", "celltype.ch1"), 
  gene_id = "ENSEMBL"
)

## visualization on aggregated data
sig_rankdensity_plot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  ID = "celltype.ch1", 
  counts = FALSE,
  aggregate =  TRUE,
  gene_id = "ENSEMBL"
)
```


## NK Score Boxplot

To see if the curated NK cells signatures have evident higher abundance in NK cells than other immune subsets, use `sig_boxplot()` function to make boxplot of the NK scores for all subsets in the data.

NK score is calculated by `singscore` package.

Obviously, our signature always shows significantly higher score in NK cells.

```{r score boxplot, warning=FALSE}
sig_boxplot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  ID = "celltype.ch1", 
  type = "NK", 
  counts = FALSE,
  gene_id = "ENSEMBL"
)

## To make boxplots for more than 1 immune datasets at once:
# result_score_boxplot(data = list(data_6 = im_data_6,
#                                  proc_data = proc_data), 
#                      sigs = sig_NK_CRC,
#                      ID = c("celltype:ch1", "label.main"),
#                      type = "NK",
#                      counts = c(TRUE, FALSE),
#                      gene_id = "ENSEMBL") *
#   guides(col = "none")
```


## NK Signature Abundance Boxplot

`result_exp_boxplot()` function can also generate boxplot of the NK signature abundance for all subsets in the data by setting `plot.score = FALSE`.

It's clear the score can increase the difference between NK cells and others.

```{r abundance boxplot, warning=FALSE}
sig_boxplot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  ID = "celltype.ch1", 
  type = "NK",
  plot.score = FALSE,
  counts = FALSE,
  gene_id = "ENSEMBL"
)
```


## NK Signature Abundance Scatter Plot

To see if the curated NK cells signature shows higher specificity to NK cells than other immune subsets. Use `sig_scatter_plot()` function to make scatter plot of the NK signature abundance for all subsets in the data.

Based on sactter plot result, we can actually do further filtration to improve signature specificity.

```{r abundance scatter plot, warning=FALSE}
sig_scatter_plot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  ID = "celltype.ch1", 
  type = "NK",
  counts = FALSE,
  xint = 2.5, yint = 2.5,
  gene_id = "ENSEMBL"
)

## To make scatter plot for more than 1 immune datasets at once:
# sig_scatter_plot(
#   data = list(data_6 = im_data_6,
#               proc_data = proc_data), 
#   sigs = sig_NK_CRC,
#   ID = c("celltype:ch1", "celltype.ch1"),
#   type = "NK", 
#   xint = 2.5, yint = 2.5,
#   counts = c(TRUE, FALSE), 
#   gene_id = "ENSEMBL")
```


## NK Signature GSEA plot

To see if the curated NK cells signature is enriched in NK cells than other immune subsets. Use `sig_gseaplot()` function to make GSEAplot.

It's clear that our screened signature is enriched in all comparisons.

```{r gseaplot, fig.width=8, fig.height=5, warning=FALSE}
sig_gseaplot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  ID = "celltype.ch1", 
  type = "NK",
  gene_id = "ENSEMBL",
  counts = FALSE
)
```


# Refine Signature Specificity

----------------------------------

According to the visualization result, we can see our NK signature shows good performance in separating NK cells with all other cells. But CD8+ T cells still show similar abundance to NK cells in some signature genes expression, which might impair the ability of signature to distinguish NK cells from CD8+ T cells.

But we know those genes with similar abundance across NK and CD8+ T are importance and distinguishable for separating NK cells from other non-CD8+ T cells. So we don't recommend to simply delete those genes based on our abundance scatter plot. 

Instead, here we implemented a better way to increase the difference between the ambiguous cell types.

By setting `keep.top` and `keep.group`, we can easily keep the top n DEGs of specified DE comparisons, DEGs are ranked based on `Rank` param. For instance, here we want keep more distinguishable genes between NK and CD8+ T cells, we can set `keep.group = "CD8"` or `keep.group = "NK-CD8"`. `keep.top` can specify how many top genes in that comparison should be kept.

We only get 2 more new genes when keeping top 200 DEGs in 'NK-CD8', that's because majority of those genes are not in our markers pool `Markers` and can't pass the screening. So it would be better to create a large enough pool for screening in case we miss any useful DEGs.

```{r signature refine}
## keep top 200 DEGs in 'NK-CD8'
m_ct_refine <- filter_subset_sig(
  data = im_data_6, 
  markers = geneIds(Markers),
  ID = "celltype:ch1",
  type = "NK",
  gene_id = "ENSEMBL",
  keep.top = 200,
  keep.group = "CD8"
)

## get 2 more new signature genes
sig_NK_CRC_refine <- intersect(m_ct_refine, m_ccl)
setdiff(sig_NK_CRC_refine, sig_NK_CRC)

## most NK-CD8 top DEGs are not in the markers pool
deg_tables <- mastR::get_de_table(
  data = im_data_6, 
  ID = "celltype:ch1",
  type = "NK"
)
intersect(mapIds(org.Hs.eg.db, rownames(deg_tables$`NK-CD8`)[1:200],
                 "SYMBOL", "ENSEMBL"),
          geneIds(Markers))  ## only 15 out of top 200 DEGs are in the pool
```


## Visualization after refinement

We can see the difference of NK vs CD4 and CD8 T cells increased, but the difference vs monocytes and neutrophils dropped a bit.

```{r score boxplot refine, warning=FALSE}
p1 <- sig_boxplot(
  data = proc_data, 
  sigs = sig_NK_CRC_refine,
  ID = "celltype.ch1", 
  type = "NK", 
  counts = FALSE,
  gene_id = "ENSEMBL"
) + ggtitle("Signature after Refinement")
p2 <- sig_boxplot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  ID = "celltype.ch1", 
  type = "NK", 
  counts = FALSE,
  gene_id = "ENSEMBL"
) + ggtitle("Signature before Refinement")

(p1 + p2)*ylim(-0.5,0.4) + patchwork::plot_layout(guides = "collect")
```

Abundance scatter plot also shows more specific genes to NK compared with CD4/8 T cells.

```{r abundance scatter plot refine, warning=FALSE}
p1 <- sig_scatter_plot(
  data = proc_data, 
  sigs = sig_NK_CRC_refine,
  ID = "celltype.ch1", 
  type = "NK",
  counts = FALSE,
  xint = 2.5, yint = 2.5,
  gene_id = "ENSEMBL"
) + ggtitle("Signature after Refinement")
p2 <- sig_scatter_plot(
  data = proc_data, 
  sigs = sig_NK_CRC,
  ID = "celltype.ch1", 
  type = "NK",
  counts = FALSE,
  xint = 2.5, yint = 2.5,
  gene_id = "ENSEMBL"
) + ggtitle("Signature before Refinement")

(p1 + p2) + patchwork::plot_layout(guides = "collect")
```


# Screen on Multiple Datasets

----------------------------------

Our package can be applied on multiple datasets. Instead of integrating datasets into one larger dataset to fit into one linear model, we screen signature in each dataset respectively and aggregating ranked lists via `RobustRankAggreg` method (as our output of signature by screening function is ordered based on the given `Rank`).

The advantage is that we can avoid over-normalizing or mis-correcting when carrying out data integration. And we can get more robust and conserved signature across datasets.

Of course, easy way such as "union" and "intersect" is also supported besides "RRA" (Robust Rank Aggreg), by setting `comb = union` or `comb = intersect`.

It's better to use union when you get only a few genes screened for each dataset, while "RRA" is better to pick up significant genes from large DEG lists, "intersect" is proper for highly overlapping gene lists.

```{r screen multiple datasets}
## As a test, we just repeatly use im_data_6 as a show case
m_ct_m <- filter_subset_sig(
  data = list(A = im_data_6, B = im_data_6), 
  markers = geneIds(Markers),
  ID = "celltype:ch1",
  type = "NK",
  gene_id = "ENSEMBL"
)

## we will get exactly the same list
## if we choose 'union' or 'intersect' as combination method
setequal(m_ct_m, m_ct)

## but we will only get the genes appear at top rank across gene lists
## if we choose 'RRA', s_thres is to determine the threshold for ranking score
m_ct_m <- filter_subset_sig(
  data = list(A = im_data_6, B = im_data_6), 
  markers = geneIds(Markers),
  ID = "celltype:ch1",
  type = "NK",
  gene_id = "ENSEMBL",
  comb = "RRA",  ## change this to use different strategy, default is "union"
  s_thres = 0.5  ## only work when comb = "RRA", set a threshold for ranking score
)

## we can get only 8 signature genes this time
m_ct_m
```


# Screen on Multiple Datasets

----------------------------------

We also provide pseudo-sample functions in this package to help users convert scRNA data into pseudo-bulk data, which can then be used in our above workflow.

`pseudo_samples()` can help aggregate cells into pseudo-sample according to the given factor.

```{r pseudo-bulk}
## create a test scRNA object of 100 genes x 100 cells
counts <- matrix(abs(rnorm(10000, 10, 10)), 100)
rownames(counts) <- 1:100
colnames(counts) <- 1:100
meta <- data.frame(
  subset = rep(c("A", "B"), 50),
  level = rep(1:4, each = 25)
)
rownames(meta) <- 1:100
pb <- pseudo_samples(counts, by = meta)

## Seurat or SCE object are also accepted
# scRNA <- Seurat::CreateSeuratObject(counts = counts, meta.data = meta)
# pseudo_samples(scRNA, by = c("subset","level"))
```



# Session Info

---------------------

```{r session info}
sessionInfo()
```

# References

---------------------

>Cursons J, Souza-Fonseca-Guimaraes F, Foroutan M, Anderson A, Hollande F, Hediyeh-Zadeh S, Behren A, Huntington ND, Davis MJ. A Gene Signature Predicting Natural Killer Cell Infiltration and Improved Survival in Melanoma Patients. Cancer Immunol Res. 2019 Jul;7(7):1162-1174. doi: 10.1158/2326-6066.CIR-18-0500. Epub 2019 May 14. PMID: 31088844.

