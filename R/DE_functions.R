#helper: use edgeR to filter low counts genes and keep genes in markers
# use before DE
filterGenes <- function(dge, group_col, filter = c(10, 10), normalize = TRUE,
                        markers = NULL, gene_id = "SYMBOL") {
  if (!is.null(markers)) {
    stopifnot("Please provide a vector of gene symbols!" = is.vector(markers))
    markers <- AnnotationDbi::select(org.Hs.eg.db::org.Hs.eg.db,
                                     markers,
                                     gene_id, "SYMBOL")
  }

  if(normalize == TRUE) {
    keep <- edgeR::filterByExpr(dge$counts,
                                group = dge$samples[[group_col]],
                                min.count = filter[1],
                                large.n = filter[2]) |
      (rownames(dge) %in% markers[[gene_id]])
  }else keep <- (Matrix::rowSums(dge$counts > filter[1]) > filter[2]) |
      (rownames(dge) %in% markers[[gene_id]])

  return(keep)
}


#helper: voom and linear regression fit for DE based on limma
voom_lm_fit <- function(dge, group_col, target_group,
                        feature_selection = c('auto', "rankproduct", "none"),
                        group = FALSE, plot = FALSE, normalize = TRUE,
                        lfc = 0, p = 0.05, batch = NULL, summary = TRUE) {

  feature_selection <- match.arg(feature_selection)

  ## group samples into binary groups if group = TRUE,
  ## otherwise use as multiple groups asis
  if (group == TRUE && feature_selection == "none") {
    dge$samples$group <- ifelse(grepl(target_group, dge$samples[[group_col]]),
                                make.names(target_group),
                                "Others") |>
      factor(levels = c(make.names(target_group), "Others"))
      ## set target_group to be the first level
  } else {
    dge$samples$group <- ifelse(grepl(target_group, dge$samples[[group_col]]),
                                make.names(target_group),
                                dge$samples[[group_col]] |> make.names()) |>
      (\(x) factor(x, levels = c(make.names(target_group),
                                 unique(x[x != make.names(target_group)]))))()
                                 ## set target_group to be the first level
  }

  ## make contrast design
  form <- formula(paste(c("~0", "group", batch), collapse = "+"))
  design <- model.matrix(form, dge$samples)
  colnames(design) <- gsub("group", "", colnames(design))
  rownames(design) <- colnames(dge)
  contrast.mat <- limma::makeContrasts(
    contrasts = c(paste(levels(dge$samples$group)[1],
                        levels(dge$samples$group)[-1],
                        sep = "-"
    )),
    ## target_group vs all the rest respectively, if group = TRUE, it's target_group vs Others
    levels = design
  )

  ## save normalized data into proc_data
  proc_data <- dge

  ## set par for plot
  if (plot && normalize) {
    op <- par(no.readonly = TRUE)
    par(mfrow = c(1, 2))
  }

  ## voom fit if data is raw counts data
  if(normalize) {
    v <- limma::voom(dge, design = design, plot = plot)
    ## save voom fitted counts into global variable
    proc_data$counts <- v$E
  }else v <- dge$counts

  ## assign proc_data as global variable
  # assign("proc_data", proc_data, envir = .GlobalEnv)

  ## linear regression fit
  fit <- limma::lmFit(v, design = design)
  tfit <- limma::contrasts.fit(fit, contrasts = contrast.mat) |>
    limma::treat(lfc = lfc)
  ## summarize the total number of DEGs
  if(summary == TRUE)
    show(limma::decideTests(tfit, lfc = lfc, p.value = p) |> summary())
  if (plot) limma::plotSA(tfit, main = "Final model: Mean-variance trend")
  if (plot && normalize) par(op)
  return(list(tfit = tfit, proc_data = proc_data))
}


#helper: return DEGs UP and DOWN list based on Rank Product
#' return DEGs UP and DOWN list based on Rank Product
#'
#' @param tfit MArrayLM object generated by [limma::treat()]
#' @param lfc num, cutoff of logFC for DE analysis
#' @param p num, cutoff of p value for DE analysis
#' @param assemble 'intersect' or 'union', whether to select intersected or
#'                  union genes of different comparisons, default 'intersect'
#' @param Rank character, the variable for ranking DEGs, can be 'logFC',
#'             'adj.P.Val'..., default 'adj.P.Val'
#' @param nperm num, permutation runs of simulating the distribution
#' @param thres num, cutoff for rank product permutation test if
#'              feature_selection = "rankproduct", default 0.05
#' @param keep.top NULL or num, whether to keep top n DEGs of specific
#'                 comparison
#' @param keep.group NULL or pattern, specify the top DEGs of which comparison
#'                   or group to be kept
#' @param ... omitted
#' @return A list of "UP" and "DOWN" genes
DEGs_RP <- function(tfit, lfc = NULL, p = 0.05, assemble = "intersect",
                    Rank = "adj.P.Val", nperm = 1e5, thres = 0.05,
                    keep.top = NULL, keep.group = NULL,
                    ...) {

  if(is.null(lfc)) lfc <- tfit$treat.lfc

  stopifnot(is.character(assemble), is.character(Rank),
            is.numeric(lfc), is.numeric(p), is.numeric(nperm))

  DEG <- list()
  UPs <- list()
  DWs <- list()
  DEGs <- list()
  for (i in seq_len(ncol(tfit))) {
    DEG[[i]] <- limma::topTreat(tfit, coef = i, number = Inf,
                                sort.by = "none") |> na.omit()
    UPs[[i]] <- subset(DEG[[i]], logFC > lfc & adj.P.Val < p)
    DWs[[i]] <- subset(DEG[[i]], logFC < -lfc & adj.P.Val < p)
    DEG[[i]]$lfc <- DEG[[i]]$logFC
    DEG[[i]]$logFC <- -abs(DEG[[i]]$logFC)
  }

  ## product of rank distribution for UPs
  genes <- lapply(UPs, rownames) |> Reduce(f = assemble)
  genes <- intersect(genes, lapply(DEG, rownames) |>
                       Reduce(f = intersect))
  if(length(genes) == 0) {
    DEGs[["UP"]] <- genes
  }else {
    # if(!is.null(rand)) set.seed(rand)
    up_dist <- lapply(UPs, function(x) {
      sample.int(length(genes), nperm, replace = TRUE)
    })
    pr_up_dist <- do.call(cbind, up_dist) |> log10() |> rowSums()
    up_pr <- lapply(DEG, function(x) rank(x[genes, Rank])) |>
      do.call(what = cbind) |> log10() |> rowSums()
    names(up_pr) <- genes
    up_pr <- up_pr[up_pr < quantile(pr_up_dist, thres)]  ## keep top rank genes
    DEGs[["UP"]] <- names(sort(up_pr))
  }


  ## PR distribution for DWs
  genes <- lapply(DWs, rownames) |> Reduce(f = assemble)
  genes <- intersect(genes, lapply(DEG, rownames) |>
                       Reduce(f = intersect))
  if(length(genes) == 0) {
    DEGs[["DOWN"]] <- genes
  }else {
    # if(!is.null(rand)) set.seed(rand)
    dw_dist <- lapply(DWs, function(x) {
      sample.int(length(genes), nperm, replace = TRUE)
    })
    pr_dw_dist <- do.call(cbind, dw_dist) |> log10() |> rowSums()
    dw_pr <- lapply(DEG, function(x) rank(x[genes, Rank])) |>
      do.call(what = cbind) |> log10() |> rowSums()
    names(dw_pr) <- genes
    dw_pr <- dw_pr[dw_pr < quantile(pr_dw_dist, thres)] ## keep top rank genes
    DEGs[["DOWN"]] <- names(sort(dw_pr))
  }


  ## keep the top DEGs in specified comparison even if they didn't pass RP test
  if(!is.null(keep.top)) {
    if(length(which(grepl(keep.group, colnames(tfit)))) < 1)
      stop("Please specify at least one valid comparison for keep.group!")
    ## get top n UP DEGs for specified comparison
    tmp <- lapply(which(grepl(keep.group, colnames(tfit))), \(i) {
      tmp <- DEG[[i]] |> dplyr::arrange(!!sym(Rank))
      tmp <- rownames(tmp)[tmp$lfc > 0][seq_len(keep.top)]
    })
    DEGs[["UP"]] <- Reduce(union, c(list(DEGs[["UP"]]), tmp))
    ## get top n DOWN DEGs for specified comparison
    tmp <- lapply(which(grepl(keep.group, colnames(tfit))), \(i) {
      tmp <- DEG[[i]] |> dplyr::arrange(!!sym(Rank))
      tmp <- rownames(tmp)[tmp$lfc < 0][seq_len(keep.top)]
    })
    DEGs[["DOWN"]] <- Reduce(union, c(list(DEGs[["DOWN"]]), tmp))
  }

  return(DEGs)
}


#helper: return DEGs UP and DOWN list based on intersection or union
#' return DEGs UP and DOWN list based on intersection or union of comparisons
#'
#' @inheritParams DEGs_RP
#' @return A list of "UP" and "DOWN" genes
DEGs_Group <- function(tfit, lfc = NULL, p = 0.05,
                       assemble = "intersect", Rank = "adj.P.Val",
                       keep.top = NULL, keep.group = NULL,
                       ...) {

  if(is.null(lfc)) lfc <- tfit$treat.lfc

  stopifnot(is.character(assemble), is.character(Rank),
            is.numeric(lfc), is.numeric(p))

  ## screen genes with p value < cutoff
  DEG <- list()
  UPs <- list()
  DWs <- list()
  DEGs <- list()
  for (i in seq_len(ncol(tfit))) {
    DEG[[i]] <- limma::topTreat(tfit, coef = i, number = Inf) |> na.omit()
    UPs[[i]] <- subset(DEG[[i]], logFC > lfc & adj.P.Val < p)
    DWs[[i]] <- subset(DEG[[i]], logFC < -lfc & adj.P.Val < p)
    DEG[[i]]$lfc <- DEG[[i]]$logFC
    DEG[[i]]$logFC <- -abs(DEG[[i]]$logFC)
  }
  DEGs[["UP"]] <- lapply(UPs, rownames) |> Reduce(f = assemble)
  DEGs[["DOWN"]] <- lapply(DWs, rownames) |> Reduce(f = assemble)
  DEGs[["UP"]] <- do.call(function(...) {
                            apply(cbind(...), 1, mean, na.rm = TRUE)
                          },
                          lapply(UPs, function(x, g) rank(x[g, Rank]),
                                 g = DEGs[["UP"]])) |>
    order() |> (\(x) DEGs[["UP"]][x])()
  DEGs[["DOWN"]] <- do.call(function(...) {
                              apply(cbind(...), 1, mean, na.rm = TRUE)
                            },
                            lapply(DWs, function(x, g) rank(x[g, Rank]),
                                   g = DEGs[["DOWN"]])) |>
    order() |> (\(x) DEGs[["DOWN"]][x])()

  ## keep the top DEGs in specified comparison even if they didn't pass RP test
  if(!is.null(keep.top) && assemble == "intersect") {
    if(length(which(grepl(keep.group, colnames(tfit)))) < 1)
      stop("Please specify at least one valid comparison for keep.group!")
    ## get top n UP DEGs for specified comparison
    tmp <- lapply(which(grepl(keep.group, colnames(tfit))), \(i) {
      tmp <- DEG[[i]] |> dplyr::arrange(!!sym(Rank))
      tmp <- rownames(tmp)[tmp$lfc > 0][seq_len(keep.top)]
    })
    DEGs[["UP"]] <- Reduce(union, c(list(DEGs[["UP"]]), tmp))
    ## get top n DOWN DEGs for specified comparison
    tmp <- lapply(which(grepl(keep.group, colnames(tfit))), \(i) {
      tmp <- DEG[[i]] |> dplyr::arrange(!!sym(Rank))
      tmp <- rownames(tmp)[tmp$lfc < 0][seq_len(keep.top)]
    })
    DEGs[["DOWN"]] <- Reduce(union, c(list(DEGs[["DOWN"]]), tmp))
  }

  return(DEGs)
}

#helper: make design and apply voom, lmfit and treat
#' return DGEList containing vfit by limma::voom (if normalize = TRUE) and
#' tfit by limma::treat
#'
#' @inheritParams de_analysis
#' @return A DGEList containing vfit and tfit
voom_fit_treat <- function(dge,
                           group_col,
                           target_group,
                           normalize = TRUE,
                           group = FALSE,
                           lfc = 0,
                           p = 0.05,
                           batch = NULL,
                           summary = TRUE,
                           ...) {

  stopifnot("Please provide column names as batch!" =
              is.null(batch) | is.vector(batch))

  stopifnot(is.logical(normalize),
            is.logical(summary),
            is.logical(group),
            is.numeric(lfc),
            is.numeric(p))

  ## group samples into binary groups if group = TRUE,
  ## otherwise use as multiple groups asis
  if (group == TRUE) {
    dge$samples$group <- ifelse(grepl(target_group, dge$samples[[group_col]]),
                                make.names(target_group),
                                "Others") |>
      factor(levels = c(make.names(target_group), "Others"))
    ## set target_group to be the first level
  } else {
    dge$samples$group <- ifelse(grepl(target_group, dge$samples[[group_col]]),
                                make.names(target_group),
                                make.names(dge$samples[[group_col]]))
    ## set target_group to be the first level
    dge$samples$group <- factor(
      dge$samples$group,
      levels = c(make.names(target_group),
                 unique(dge$samples$group[dge$samples$group != make.names(target_group)]))
    )
  }

  ## make contrast design
  form <- formula(paste(c("~0", "group", batch), collapse = "+"))
  design <- model.matrix(form, dge$samples)
  colnames(design) <- gsub("group", "", colnames(design))
  rownames(design) <- colnames(dge)
  contrast.mat <- limma::makeContrasts(
    contrasts = c(paste(levels(dge$samples$group)[1],
                        levels(dge$samples$group)[-1],
                        sep = "-"
    )),
    ## target_group vs all the rest respectively
    ## if group = TRUE, it's target_group vs Others
    levels = design
  )

  ## voom fit if data is raw counts data
  if(normalize == TRUE) {
    vfit <- limma::voom(dge, design = design)
    dge$vfit <- vfit
  }else dge$vfit <- dge$counts

  ## linear regression fit
  fit <- limma::lmFit(dge$vfit, design = design)
  tfit <- limma::contrasts.fit(fit, contrasts = contrast.mat) |>
    limma::treat(lfc = lfc)
  ## summarize the total number of DEGs
  if(summary == TRUE)
    show(limma::decideTests(tfit, lfc = lfc, p.value = p) |> summary())

  dge$tfit <- tfit

  return(dge)
}

utils::globalVariables(c("logFC", "adj.P.Val"))

